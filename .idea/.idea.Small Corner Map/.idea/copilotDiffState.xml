<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Helpers/MinimapUIFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Helpers/MinimapUIFactory.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating minimap UI GameObjects.&#10;    /// &lt;/summary&gt;&#10;    public static class MinimapUIFactory&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Creates the root canvas for the minimap UI.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the canvas to.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created canvas GameObject.&lt;/returns&gt;&#10;        public static GameObject CreateCanvas(GameObject parent)&#10;        {&#10;            var canvasObject = new GameObject(&quot;MinimapCanvas&quot;);&#10;            canvasObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var canvas = canvasObject.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 9999;&#10;            &#10;            var canvasScaler = canvasObject.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;            canvasScaler.referenceResolution = new Vector2(1920f, 1080f);&#10;            &#10;            canvasObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;&#10;            return canvasObject;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap frame (positions minimap in the corner).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the frame to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the frame.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created frame GameObject and its RectTransform.&lt;/returns&gt;&#10;        public static (GameObject frameObject, RectTransform rectTransform) CreateFrame(GameObject parent, float size)&#10;        {&#10;            var frameObject = new GameObject(&quot;MinimapFrame&quot;);&#10;            frameObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var rectTransform = frameObject.AddComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(1f, 1f);&#10;            rectTransform.anchorMax = new Vector2(1f, 1f);&#10;            rectTransform.pivot = new Vector2(1f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(-20f, -20f);&#10;            rectTransform.sizeDelta = new Vector2(size, size);&#10;&#10;            return (frameObject, rectTransform);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap mask (circular area for minimap).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the mask to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the mask.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created mask GameObject and its Image component.&lt;/returns&gt;&#10;        public static (GameObject maskObject, Image maskImage) CreateMask(GameObject parent, float size)&#10;        {&#10;            var maskObject = new GameObject(&quot;MinimapMask&quot;);&#10;            maskObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var maskRect = maskObject.AddComponent&lt;RectTransform&gt;();&#10;            maskRect.sizeDelta = new Vector2(size, size);&#10;            maskRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            maskRect.pivot = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchoredPosition = Vector2.zero;&#10;            &#10;            maskObject.AddComponent&lt;Mask&gt;().showMaskGraphic = false;&#10;            &#10;            var maskImage = maskObject.AddComponent&lt;Image&gt;();&#10;            maskImage.sprite = CreateCircleSprite((int)size, Color.black);&#10;            maskImage.type = Image.Type.Sliced;&#10;            maskImage.color = Color.black;&#10;&#10;            return (maskObject, maskImage);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates a filled circle sprite for the minimap mask/background.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;diameter&quot;&gt;Diameter of the circle in pixels.&lt;/param&gt;&#10;        /// &lt;param name=&quot;color&quot;&gt;Color of the circle.&lt;/param&gt;&#10;        /// &lt;param name=&quot;resolutionMultiplier&quot;&gt;Resolution multiplier for higher quality.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created circle sprite.&lt;/returns&gt;&#10;        public static Sprite CreateCircleSprite(int diameter, Color color, int resolutionMultiplier = 1)&#10;        {&#10;            var texSize = diameter * resolutionMultiplier;&#10;            var texture = new Texture2D(texSize, texSize, TextureFormat.ARGB32, false)&#10;            {&#10;                filterMode = FilterMode.Bilinear&#10;            };&#10;            &#10;            var clear = new Color(0f, 0f, 0f, 0f);&#10;            for (var i = 0; i &lt; texSize; i++)&#10;                for (var j = 0; j &lt; texSize; j++)&#10;                    texture.SetPixel(j, i, clear);&#10;            &#10;            var radius = texSize / 2;&#10;            var center = new Vector2(radius, radius);&#10;            &#10;            for (var k = 0; k &lt; texSize; k++)&#10;                for (var l = 0; l &lt; texSize; l++)&#10;                    if (Vector2.Distance(new Vector2(l, k), center) &lt;= radius)&#10;                        texture.SetPixel(l, k, color);&#10;            &#10;            texture.Apply();&#10;            return Sprite.Create(texture, new Rect(0f, 0f, texSize, texSize), new Vector2(0.5f, 0.5f), resolutionMultiplier);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the player marker GameObject.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the marker to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;markerColor&quot;&gt;Color for the marker.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the marker.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created player marker GameObject.&lt;/returns&gt;&#10;        public static GameObject CreatePlayerMarker(GameObject parent, Color markerColor, float size = 10f)&#10;        {&#10;            var marker = new GameObject(&quot;PlayerMarker&quot;);&#10;            marker.transform.SetParent(parent.transform, false);&#10;            &#10;            var rect = marker.AddComponent&lt;RectTransform&gt;();&#10;            rect.sizeDelta = new Vector2(size, size);&#10;            rect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            rect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            rect.pivot = new Vector2(0.5f, 0.5f);&#10;            rect.anchoredPosition = Vector2.zero;&#10;            &#10;            var image = marker.AddComponent&lt;Image&gt;();&#10;            image.color = markerColor;&#10;&#10;            // Ensure player marker is drawn on top&#10;            marker.transform.SetAsLastSibling();&#10;&#10;            return marker;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the direction indicator for the player marker.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject (player marker) to attach the indicator to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;indicatorColor&quot;&gt;Color for the indicator.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the indicator.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created direction indicator RectTransform.&lt;/returns&gt;&#10;        public static RectTransform CreateDirectionIndicator(GameObject parent, Color indicatorColor, float size = Constants.DirectionIndicatorSize)&#10;        {&#10;            var indicatorObject = new GameObject(&quot;DirectionIndicator&quot;);&#10;            indicatorObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var directionIndicator = indicatorObject.AddComponent&lt;RectTransform&gt;();&#10;            directionIndicator.sizeDelta = new Vector2(size, size);&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            &#10;            var image = indicatorObject.AddComponent&lt;Image&gt;();&#10;            image.color = indicatorColor;&#10;&#10;            return directionIndicator;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating minimap UI GameObjects.&#10;    /// &lt;/summary&gt;&#10;    public static class MinimapUIFactory&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Creates the root canvas for the minimap UI.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the canvas to.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created canvas GameObject.&lt;/returns&gt;&#10;        public static GameObject CreateCanvas(GameObject parent)&#10;        {&#10;            var canvasObject = new GameObject(&quot;MinimapCanvas&quot;);&#10;            canvasObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var canvas = canvasObject.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 9999;&#10;            &#10;            var canvasScaler = canvasObject.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;            canvasScaler.referenceResolution = new Vector2(1920f, 1080f);&#10;            &#10;            canvasObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;&#10;            return canvasObject;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap frame (positions minimap in the corner).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the frame to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the frame.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created frame GameObject and its RectTransform.&lt;/returns&gt;&#10;        public static (GameObject frameObject, RectTransform rectTransform) CreateFrame(GameObject parent, float size)&#10;        {&#10;            var frameObject = new GameObject(&quot;MinimapFrame&quot;);&#10;            frameObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var rectTransform = frameObject.AddComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(1f, 1f);&#10;            rectTransform.anchorMax = new Vector2(1f, 1f);&#10;            rectTransform.pivot = new Vector2(1f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(-20f, -20f);&#10;            rectTransform.sizeDelta = new Vector2(size, size);&#10;&#10;            return (frameObject, rectTransform);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap mask (circular area for minimap).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the mask to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the mask.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created mask GameObject and its Image component.&lt;/returns&gt;&#10;        public static (GameObject maskObject, Image maskImage) CreateMask(GameObject parent, float size)&#10;        {&#10;            var maskObject = new GameObject(&quot;MinimapMask&quot;);&#10;            maskObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var maskRect = maskObject.AddComponent&lt;RectTransform&gt;();&#10;            maskRect.sizeDelta = new Vector2(size, size);&#10;            maskRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            maskRect.pivot = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchoredPosition = Vector2.zero;&#10;            &#10;            maskObject.AddComponent&lt;Mask&gt;().showMaskGraphic = false;&#10;            &#10;            var maskImage = maskObject.AddComponent&lt;Image&gt;();&#10;            maskImage.sprite = CreateCircleSprite((int)size, Color.black);&#10;            maskImage.type = Image.Type.Sliced;&#10;            maskImage.color = Color.black;&#10;&#10;            return (maskObject, maskImage);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates a filled circle sprite for the minimap mask/background.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;diameter&quot;&gt;Diameter of the circle in pixels.&lt;/param&gt;&#10;        /// &lt;param name=&quot;color&quot;&gt;Color of the circle.&lt;/param&gt;&#10;        /// &lt;param name=&quot;resolutionMultiplier&quot;&gt;Resolution multiplier for higher quality.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created circle sprite.&lt;/returns&gt;&#10;        public static Sprite CreateCircleSprite(int diameter, Color color, int resolutionMultiplier = 1)&#10;        {&#10;            var texSize = diameter * resolutionMultiplier;&#10;            var texture = new Texture2D(texSize, texSize, TextureFormat.ARGB32, false)&#10;            {&#10;                filterMode = FilterMode.Bilinear&#10;            };&#10;            &#10;            var clear = new Color(0f, 0f, 0f, 0f);&#10;            for (var i = 0; i &lt; texSize; i++)&#10;                for (var j = 0; j &lt; texSize; j++)&#10;                    texture.SetPixel(j, i, clear);&#10;            &#10;            var radius = texSize / 2;&#10;            var center = new Vector2(radius, radius);&#10;            &#10;            for (var k = 0; k &lt; texSize; k++)&#10;                for (var l = 0; l &lt; texSize; l++)&#10;                    if (Vector2.Distance(new Vector2(l, k), center) &lt;= radius)&#10;                        texture.SetPixel(l, k, color);&#10;            &#10;            texture.Apply();&#10;            return Sprite.Create(texture, new Rect(0f, 0f, texSize, texSize), new Vector2(0.5f, 0.5f), resolutionMultiplier);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the player marker GameObject.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the marker to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;markerColor&quot;&gt;Color for the marker.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the marker.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created player marker GameObject.&lt;/returns&gt;&#10;        public static GameObject CreatePlayerMarker(GameObject parent, Color markerColor, float size = 10f)&#10;        {&#10;            var marker = new GameObject(&quot;PlayerMarker&quot;);&#10;            marker.transform.SetParent(parent.transform, false);&#10;            &#10;            var rect = marker.AddComponent&lt;RectTransform&gt;();&#10;            rect.sizeDelta = new Vector2(size, size);&#10;            rect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            rect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            rect.pivot = new Vector2(0.5f, 0.5f);&#10;            rect.anchoredPosition = Vector2.zero;&#10;            &#10;            var image = marker.AddComponent&lt;Image&gt;();&#10;            image.color = markerColor;&#10;&#10;            // Ensure player marker is drawn on top&#10;            marker.transform.SetAsLastSibling();&#10;&#10;            return marker;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the direction indicator for the player marker.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject (player marker) to attach the indicator to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;indicatorColor&quot;&gt;Color for the indicator.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the indicator.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created direction indicator RectTransform.&lt;/returns&gt;&#10;        public static RectTransform CreateDirectionIndicator(GameObject parent, Color indicatorColor, float size = Constants.DirectionIndicatorSize)&#10;        {&#10;            var indicatorObject = new GameObject(&quot;DirectionIndicator&quot;);&#10;            indicatorObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var directionIndicator = indicatorObject.AddComponent&lt;RectTransform&gt;();&#10;            directionIndicator.sizeDelta = new Vector2(size, size);&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            &#10;            var image = indicatorObject.AddComponent&lt;Image&gt;();&#10;            image.color = indicatorColor;&#10;&#10;            return directionIndicator;&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/ContractMarkerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/ContractMarkerManager.cs" />
              <option name="originalContent" value="#if IL2CPP&#10;using Il2CppScheduleOne.Economy;&#10;using Il2CppScheduleOne.Quests;&#10;#else&#10;using ScheduleOne.Economy;&#10;using ScheduleOne.Quests;&#10;#endif&#10;&#10;using HarmonyLib;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class ContractMarkerManager&#10;    {&#10;        private GameObject contractPoIIconPrefab;&#10;        private float mapScale;&#10;        private readonly float markerXAdjustment;&#10;        private GameObject mapContentObject;&#10;        private MinimapContent mapContent;&#10;        private readonly MapPreferences mapPreferences;&#10;&#10;        private const string ContractPoIMarkerKey = &quot;ContractPoI_Marker&quot;;&#10;&#10;        public ContractMarkerManager(MinimapContent minimapContent, float mapScale, float markerXAdjustment, float markerZAdjustment, MapPreferences preferences)&#10;        {&#10;            this.mapContent = minimapContent;&#10;            this.mapContentObject = minimapContent.MapContentObject;&#10;            this.mapScale = mapScale;&#10;            this.markerXAdjustment = markerXAdjustment;&#10;            this.mapPreferences = preferences;&#10;        }&#10;&#10;        public void SetMapContentObject(GameObject mapContentObject)&#10;        {&#10;            // Correctly store the provided map content GameObject&#10;            this.mapContentObject = mapContentObject;&#10;        }&#10;        &#10;        public void UpdateMapScale(float newMapScale)&#10;        {&#10;            mapScale = newMapScale;&#10;        }&#10;&#10;        internal void AddContractPoIMarkerWorld(Contract contract)&#10;        {&#10;            if (contract == null || mapContentObject == null)&#10;                return;&#10;&#10;            // Use current dynamic scale factor from preferences&#10;            var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;            &#10;            Vector3 worldPos = contract.DeliveryLocation.CustomerStandPoint.position;&#10;            var xPosition = worldPos.x * currentScale;&#10;            var zPosition = worldPos.z * currentScale;&#10;            Vector2 mappedPos = new Vector2(xPosition, zPosition);&#10;&#10;            if (mapContentObject != null)&#10;            {&#10;                if (contractPoIIconPrefab == null)&#10;                {&#10;                    CacheContractPoIIcon(contract);&#10;                }&#10;&#10;                MinimapPoIHelper.AddMarkersToMap(&#10;                    contractPoIIconPrefab,&#10;                    mapContentObject,&#10;                    ContractPoIMarkerKey + &quot;_&quot; + contract.GUID,&#10;                    mappedPos,&#10;                    worldPos,&#10;                    -markerXAdjustment,&#10;                    0f);&#10;            }&#10;        }&#10;&#10;        internal void RemoveContractPoIMarkers(Contract contract)&#10;        {&#10;            var name = ContractPoIMarkerKey + &quot;_&quot; + contract.GUID;&#10;            MinimapPoIHelper.RemoveMarker(name);&#10;        }&#10;&#10;        internal void RemoveAllContractPoIMarkers()&#10;        {&#10;            MinimapPoIHelper.RemoveAllByKey(ContractPoIMarkerKey);&#10;        }&#10;&#10;        private void CacheContractPoIIcon(Contract contract)&#10;        {&#10;            contractPoIIconPrefab = contract.IconPrefab.gameObject;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#if IL2CPP&#10;using Il2CppScheduleOne.Economy;&#10;using Il2CppScheduleOne.Quests;&#10;#else&#10;using ScheduleOne.Economy;&#10;using ScheduleOne.Quests;&#10;#endif&#10;&#10;using HarmonyLib;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class ContractMarkerManager&#10;    {&#10;        private GameObject contractPoIIconPrefab;&#10;        private float mapScale;&#10;        private readonly float markerXAdjustment;&#10;        private GameObject mapContentObject;&#10;        private MinimapContent mapContent;&#10;        private readonly MapPreferences mapPreferences;&#10;&#10;        private const string ContractPoIMarkerKey = &quot;ContractPoI_Marker&quot;;&#10;&#10;        public ContractMarkerManager(MinimapContent minimapContent, float mapScale, float markerXAdjustment, float markerZAdjustment, MapPreferences preferences)&#10;        {&#10;            this.mapContent = minimapContent;&#10;            this.mapContentObject = minimapContent.MapContentObject;&#10;            this.mapScale = mapScale;&#10;            this.markerXAdjustment = markerXAdjustment;&#10;            this.mapPreferences = preferences;&#10;        }&#10;&#10;        public void SetMapContentObject(GameObject mapContentObject)&#10;        {&#10;            // Correctly store the provided map content GameObject&#10;            this.mapContentObject = mapContentObject;&#10;        }&#10;        &#10;        public void UpdateMapScale(float newMapScale)&#10;        {&#10;            mapScale = newMapScale;&#10;        }&#10;&#10;        internal void AddContractPoIMarkerWorld(Contract contract)&#10;        {&#10;            if (contract == null || mapContentObject == null)&#10;                return;&#10;&#10;            // Use current dynamic scale factor from preferences&#10;            var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;            &#10;            Vector3 worldPos = contract.DeliveryLocation.CustomerStandPoint.position;&#10;            var xPosition = worldPos.x * currentScale;&#10;            var zPosition = worldPos.z * currentScale;&#10;            Vector2 mappedPos = new Vector2(xPosition, zPosition);&#10;&#10;            if (mapContentObject != null)&#10;            {&#10;                if (contractPoIIconPrefab == null)&#10;                {&#10;                    CacheContractPoIIcon(contract);&#10;                }&#10;&#10;                MinimapPoIHelper.AddMarkersToMap(&#10;                    contractPoIIconPrefab,&#10;                    mapContentObject,&#10;                    ContractPoIMarkerKey + &quot;_&quot; + contract.GUID,&#10;                    mappedPos,&#10;                    worldPos,&#10;                    -markerXAdjustment,&#10;                    0f);&#10;            }&#10;        }&#10;&#10;        internal void RemoveContractPoIMarkers(Contract contract)&#10;        {&#10;            var name = ContractPoIMarkerKey + &quot;_&quot; + contract.GUID;&#10;            MinimapPoIHelper.RemoveMarker(name);&#10;        }&#10;&#10;        internal void RemoveAllContractPoIMarkers()&#10;        {&#10;            MinimapPoIHelper.RemoveAllByKey(ContractPoIMarkerKey);&#10;        }&#10;&#10;        private void CacheContractPoIIcon(Contract contract)&#10;        {&#10;            contractPoIIconPrefab = contract.IconPrefab.gameObject;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/MinimapUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/MinimapUI.cs" />
              <option name="originalContent" value="#if IL2CPP&#10;using S1Quests = Il2CppScheduleOne.Quests;&#10;#else&#10;using S1Quests = ScheduleOne.Quests;&#10;#endif&#10;&#10;using S1API.Entities;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using System.Collections;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main;&#10;&#10;// The main orchestrator for the minimap UI and its managers.&#10;public class MinimapUI&#10;{&#10;    // --- Managers and Content ---&#10;    // Handles map content (image, grid, static markers)&#10;    private MinimapContent minimapContent;&#10;    // Handles player marker and direction indicator&#10;    private PlayerMarkerManager playerMarkerManager;&#10;    // Handles minimap time display&#10;    private MinimapTimeDisplay minimapTimeDisplay;&#10;&#10;    // --- UI GameObjects ---&#10;    private GameObject minimapObject;           // Root object for the minimap UI&#10;    private GameObject minimapDisplayObject;    // The mask object for the minimap&#10;    private RectTransform minimapFrameRect;     // The frame (positioned in the corner)&#10;&#10;    // --- State ---&#10;    private readonly MapPreferences mapPreferences;&#10;    private bool initialized = false;&#10;    &#10;    // --- Scaled sizes (calculated at runtime) ---&#10;    private float scaledMinimapSize;&#10;    private float scaledMapContentSize;&#10;    private Image minimapMaskImage; // Cache for regenerating mask sprite&#10;&#10;    // --- Cached Player Reference ---&#10;    private Player playerObject;&#10;&#10;    // Handles contract PoI markers&#10;    private ContractMarkerManager ContractMarkerManager { get; set; }&#10;&#10;    private bool TimeBarEnabled =&gt; mapPreferences.ShowGameTime.Value;&#10;    private bool MinimapEnabled =&gt; mapPreferences.MinimapEnabled.Value;&#10;&#10;    // Dynamic world-to-minimap scale reflecting user preference.&#10;    private float CurrentWorldScale =&gt; Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;&#10;    public MinimapUI(MapPreferences preferences)&#10;    {&#10;        mapPreferences = preferences;&#10;        mapPreferences.MinimapEnabled.OnEntryValueChanged.Subscribe(OnMinimapEnableChanged);&#10;        mapPreferences.ShowGameTime.OnEntryValueChanged.Subscribe(OnTimeBarEnableChanged);&#10;        mapPreferences.IncreaseSize.OnEntryValueChanged.Subscribe(OnIncreaseSizeChanged);&#10;        RecalculateScaledSizes();&#10;    }&#10;    &#10;    private void RecalculateScaledSizes()&#10;    {&#10;        var scale = mapPreferences.MinimapScaleFactor;&#10;        scaledMinimapSize = Constants.BaseMinimapSize * scale;&#10;        scaledMapContentSize = Constants.BaseMapContentSize * scale;&#10;    }&#10;    &#10;    private void OnIncreaseSizeChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (!initialized) return;&#10;        RecalculateScaledSizes();&#10;        UpdateMinimapSize(true); // regenerate mask sprite&#10;&#10;        // Update scale in ContractMarkerManager&#10;        var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;        ContractMarkerManager?.UpdateMapScale(currentScale);&#10;        &#10;        // Reproject all PoI markers using new scale&#10;        MinimapPoIHelper.UpdateAllMarkerPositions(CurrentWorldScale);&#10;        // Immediately recenter content so player marker remains centered after size jump&#10;        UpdateMinimap();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes the minimap UI and starts integration and update coroutines.&#10;    /// &lt;/summary&gt;&#10;    public void Initialize()&#10;    {&#10;        if (!MinimapEnabled) return;&#10;        CreateMinimapDisplay();&#10;        StartSceneIntegration();    // Finds map sprite, player, and sets up markers&#10;        StartMinimapUpdateLoop();   // Continuously updates minimap as player moves&#10;        initialized = true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cleans up the minimap UI when the scene changes or mod is unloaded.&#10;    /// &lt;/summary&gt;&#10;    public void Dispose()&#10;    {&#10;        if (minimapObject == null) return;&#10;        UnityEngine.Object.Destroy(minimapObject);&#10;        minimapObject = null;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates the minimap UI hierarchy, including mask, background, content, and managers.&#10;    /// &lt;/summary&gt;&#10;    private void CreateMinimapDisplay()&#10;    {&#10;        RecalculateScaledSizes();&#10;        &#10;        // Root container for minimap UI&#10;        minimapObject = new GameObject(&quot;MinimapContainer&quot;);&#10;        UnityEngine.Object.DontDestroyOnLoad(minimapObject);&#10;&#10;        // Canvas for UI rendering&#10;        var canvasObject = MinimapUIFactory.CreateCanvas(minimapObject);&#10;&#10;        // Frame (positions minimap in the corner)&#10;        var (frameObject, frameRect) = MinimapUIFactory.CreateFrame(canvasObject, scaledMinimapSize);&#10;        minimapFrameRect = frameRect;&#10;&#10;        // Mask (circular area for minimap)&#10;        var (maskObject, maskImage) = MinimapUIFactory.CreateMask(frameObject, scaledMinimapSize);&#10;        minimapDisplayObject = maskObject;&#10;        minimapMaskImage = maskImage;&#10;&#10;        // Map content (holds the map image, grid, and markers)&#10;        minimapContent = new MinimapContent(&#10;            scaledMapContentSize, &#10;            20, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor);&#10;        minimapContent.Create(maskObject);&#10;        TryApplyMapSprite(); // Try to assign the map image immediately&#10;&#10;        // Player marker (centered in the minimap)&#10;        playerMarkerManager = new PlayerMarkerManager();&#10;        playerMarkerManager.CreatePlayerMarker(maskObject);&#10;&#10;        // Contract PoI markers&#10;        ContractMarkerManager = new ContractMarkerManager(&#10;            minimapContent, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor, &#10;            Constants.ContractMarkerXOffset, &#10;            Constants.ContractMarkerZOffset,&#10;            mapPreferences);&#10;&#10;        // Time display (shows in-game time)&#10;        minimapTimeDisplay = new MinimapTimeDisplay();&#10;        minimapTimeDisplay.Create(minimapFrameRect, mapPreferences.ShowGameTime);&#10;    }&#10;&#10;    private void OnMinimapEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;&#10;        if (newValue &amp;&amp; !initialized)&#10;        {&#10;            Initialize();&#10;        }&#10;&#10;        if (oldValue == newValue) return;&#10;        if (minimapDisplayObject != null)&#10;            minimapDisplayObject.SetActive(MinimapEnabled);&#10;&#10;        if (MinimapEnabled)&#10;        {&#10;            UpdateMinimapSize();&#10;        }&#10;&#10;        minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;    }&#10;&#10;    private void OnTimeBarEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (oldValue != newValue)&#10;        {&#10;            minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap and its elements when the size changes (e.g., 2x toggle).&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimapSize(bool regenerateMaskSprite = false)&#10;    {&#10;        RecalculateScaledSizes();&#10;&#10;        if (minimapFrameRect != null)&#10;            minimapFrameRect.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;&#10;        if (minimapDisplayObject != null)&#10;        {&#10;            var component = minimapDisplayObject.GetComponent&lt;RectTransform&gt;();&#10;            component.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;            &#10;            if (regenerateMaskSprite &amp;&amp; minimapMaskImage != null)&#10;                minimapMaskImage.sprite = MinimapUIFactory.CreateCircleSprite((int)scaledMinimapSize, Color.black);&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null) return;&#10;        var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentRect != null)&#10;            contentRect.sizeDelta = new Vector2(scaledMapContentSize, scaledMapContentSize);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to find and assign the map sprite from the game's UI to the minimap.&#10;    /// &lt;/summary&gt;&#10;    private void TryApplyMapSprite()&#10;    {&#10;        &#10;        var contentGo = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        Image contentImage = null;&#10;        if (contentGo != null)&#10;        {&#10;            contentImage = contentGo.GetComponent&lt;Image&gt;();&#10;            if (contentImage == null &amp;&amp; contentGo.transform.childCount &gt; 0)&#10;                contentImage = contentGo.transform.GetChild(0).GetComponent&lt;Image&gt;();&#10;        }&#10;&#10;        if (contentImage != null &amp;&amp; minimapContent != null)&#10;        {&#10;            var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;            if (minimapImage == null)&#10;                minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;&#10;            minimapImage.sprite = contentImage.sprite;&#10;            minimapImage.type = Image.Type.Simple;&#10;            minimapImage.preserveAspect = true;&#10;            minimapImage.enabled = true;&#10;            MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap.&quot;);&#10;        }&#10;        else&#10;        {&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find map sprite to apply to minimap.&quot;);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that integrates the minimap with the scene (finds player, map, markers).&#10;    /// &lt;/summary&gt;&#10;    private void StartSceneIntegration()&#10;    {&#10;        MelonCoroutines.Start(SceneIntegrationRoutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that finds the player, map sprite, and sets up markers after the scene loads.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator SceneIntegrationRoutine()&#10;    {&#10;        MelonLogger.Msg(&quot;MinimapUI: Looking for game objects...&quot;);&#10;&#10;        yield return new WaitForSeconds(2f);&#10;&#10;        GameObject mapAppObject = null;&#10;        GameObject viewportObject = null;&#10;&#10;        var attempts = 0;&#10;        while ((mapAppObject == null || playerObject == null) &amp;&amp; attempts &lt; 30)&#10;        {&#10;            attempts++;&#10;&#10;            // Find player by looking for a CharacterController not at world origin&#10;            playerObject ??= Player.Local;&#10;&#10;            // Find the MapApp UI object&#10;            if (mapAppObject == null)&#10;            {&#10;                var gameplayMenu = GameObject.Find(&quot;GameplayMenu&quot;);&#10;                if (gameplayMenu != null)&#10;                {&#10;                    var phoneTransform = gameplayMenu.transform.Find(&quot;Phone&quot;);&#10;                    if (phoneTransform != null)&#10;                    {&#10;                        var phoneChildTransform = phoneTransform.Find(&quot;phone&quot;);&#10;                        if (phoneChildTransform != null)&#10;                        {&#10;                            var appsCanvas = phoneChildTransform.Find(&quot;AppsCanvas&quot;);&#10;                            if (appsCanvas != null)&#10;                            {&#10;                                var mapApp = appsCanvas.Find(&quot;MapApp&quot;);&#10;                                if (mapApp != null)&#10;                                {&#10;                                    mapAppObject = mapApp.gameObject;&#10;                                    MelonLogger.Msg(&quot;MinimapUI: Found MapApp&quot;);&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Find the viewport (where the map image is)&#10;            if (mapAppObject != null &amp;&amp; viewportObject == null)&#10;            {&#10;                var container = mapAppObject.transform.Find(&quot;Container&quot;);&#10;                if (container != null)&#10;                {&#10;                    var scrollView = container.Find(&quot;Scroll View&quot;);&#10;                    if (scrollView != null)&#10;                    {&#10;                        var viewport = scrollView.Find(&quot;Viewport&quot;);&#10;                        if (viewport != null)&#10;                        {&#10;                            viewportObject = viewport.gameObject;&#10;                            MelonLogger.Msg(&quot;MinimapUI: Found Map Viewport&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (mapAppObject == null || playerObject == null)&#10;                yield return new WaitForSeconds(Constants.SceneIntegrationRetryDelay);&#10;        }&#10;&#10;        if (mapAppObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Map App after multiple attempts&quot;);&#10;        else if (viewportObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Found MapApp but could not find Viewport&quot;);&#10;        if (playerObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Player after multiple attempts&quot;);&#10;&#10;        MelonLogger.Msg(&quot;MinimapUI: Game object search completed&quot;);&#10;&#10;        // Apply map sprite from the viewport's content image&#10;        if (viewportObject != null)&#10;        {&#10;            try&#10;            {&#10;                if (viewportObject.transform.childCount &gt; 0)&#10;                {&#10;                    var contentTransform = viewportObject.transform.GetChild(0);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Found viewport content: &quot; + contentTransform.name);&#10;                    var contentImage = contentTransform.GetComponent&lt;Image&gt;();&#10;&#10;                    if (contentImage != null &amp;&amp; contentImage.sprite != null)&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Found content image with sprite: &quot; + contentImage.sprite.name);&#10;&#10;                        var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                        if (minimapImage == null)&#10;                            minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                        minimapImage.sprite = contentImage.sprite;&#10;                        minimapImage.type = Image.Type.Simple;&#10;                        minimapImage.preserveAspect = true;&#10;                        minimapImage.enabled = true;&#10;                        MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                        if (minimapContent.GridContainer != null)&#10;                            minimapContent.GridContainer.gameObject.SetActive(false);&#10;                    }&#10;                    else&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Content doesn't have an Image component or sprite&quot;);&#10;                        // Try children for a valid image&#10;                        var childCount = contentTransform.childCount;&#10;                        for (var i = 0; i &lt; childCount; i++)&#10;                        {&#10;                            var child = contentTransform.GetChild(i);&#10;                            var childImage = child.GetComponent&lt;Image&gt;();&#10;                            if (childImage != null &amp;&amp; childImage.sprite != null)&#10;                            {&#10;                                MelonLogger.Msg(&quot;MinimapUI: Found image in content child: &quot; + child.name + &quot;, Sprite: &quot; + childImage.sprite.name);&#10;&#10;                                var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                                if (minimapImage == null)&#10;                                    minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                                minimapImage.sprite = childImage.sprite;&#10;                                minimapImage.type = Image.Type.Simple;&#10;                                minimapImage.preserveAspect = true;&#10;                                minimapImage.enabled = true;&#10;                                MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                                if (minimapContent.GridContainer != null)&#10;                                    minimapContent.GridContainer.gameObject.SetActive(false);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;MinimapUI: Error accessing map content: &quot; + ex.Message);&#10;            }&#10;        }&#10;&#10;        // Replace fallback player marker with real icon if available&#10;        var cachedMapContent = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        if (cachedMapContent != null)&#10;        {&#10;            var playerPoI = cachedMapContent.transform.Find(&quot;PlayerPoI(Clone)&quot;);&#10;            if (playerPoI != null)&#10;            {&#10;                var realIcon = playerPoI.Find(&quot;IconContainer&quot;);&#10;                if (realIcon != null)&#10;                {&#10;                    playerMarkerManager.ReplaceWithRealPlayerIcon(realIcon.gameObject);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Replaced fallback player marker with real player icon.&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add default static markers if possible&#10;        if (cachedMapContent != null)&#10;        {&#10;            var propertyPoI = cachedMapContent.transform.Find(&quot;PropertyPoI(Clone)&quot;);&#10;            if (propertyPoI == null) yield break;&#10;            &#10;            var iconContainer = propertyPoI.Find(&quot;IconContainer&quot;);&#10;            if (iconContainer == null) yield break;&#10;            &#10;            PropertyPoIManager.Initialize(minimapContent, iconContainer);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that updates the minimap every frame.&#10;    /// &lt;/summary&gt;&#10;    private void StartMinimapUpdateLoop()&#10;    {&#10;        MelonCoroutines.Start(MinimapUpdateLoopCoroutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that updates the minimap's content position and player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator MinimapUpdateLoopCoroutine()&#10;    {&#10;        while (true)&#10;        {&#10;            UpdateMinimap();&#10;            yield return null;&#10;        }&#10;        // ReSharper disable once IteratorNeverReturns&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap's content position to keep the player centered, and updates the player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimap()&#10;    {&#10;        if (playerObject == null)&#10;        {&#10;            playerObject = Player.Local;&#10;&#10;            if (playerObject == null)&#10;                return;&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null)&#10;            return;&#10;        &#10;        // Use dynamic world scale that reflects current minimap size preference&#10;        var worldScale = CurrentWorldScale;&#10;        var position = playerObject.Position;&#10;        var mappedX = -position.x * worldScale;&#10;        var mappedZ = -position.z * worldScale;&#10;        var minimapMask = minimapDisplayObject.transform.Find(&quot;MinimapMask&quot;);&#10;        var zero = Vector2.zero;&#10;&#10;        if (minimapMask != null)&#10;        {&#10;            var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;            if (contentRect != null)&#10;            {&#10;                var rect = contentRect.rect;&#10;                var halfWidth = rect.width * 0.5f;&#10;                contentRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                zero = new Vector2(halfWidth, rect.height * 0.5f);&#10;            }&#10;        }&#10;&#10;        // Position of the player marker on the minimap (offset scaled with map)&#10;        var scaleFactor = mapPreferences.MinimapScaleFactor;&#10;        var sizeVector = new Vector2(&#10;            Constants.PlayerMarkerOffsetX * scaleFactor, &#10;            Constants.PlayerMarkerOffsetZ * scaleFactor);&#10;        var heightVector = new Vector2(mappedX, mappedZ) + zero + sizeVector;&#10;&#10;        var contentObject = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentObject != null)&#10;        {&#10;            contentObject.anchoredPosition = Vector2.Lerp(&#10;                contentObject.anchoredPosition,&#10;                heightVector,&#10;                Time.deltaTime * Constants.MapContentLerpSpeed);&#10;&#10;            // Update player marker direction indicator&#10;            playerMarkerManager?.UpdateDirectionIndicator(playerObject.Transform);&#10;        }&#10;        &#10;        minimapTimeDisplay.UpdateMinimapTime();&#10;    }&#10;&#10;&#10;    internal void OnContractAccepted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.AddContractPoIMarkerWorld(contract);&#10;    }&#10;&#10;    internal void OnContractCompleted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.RemoveContractPoIMarkers(contract);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#if IL2CPP&#10;using S1Quests = Il2CppScheduleOne.Quests;&#10;#else&#10;using S1Quests = ScheduleOne.Quests;&#10;#endif&#10;&#10;using S1API.Entities;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using System.Collections;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main;&#10;&#10;// The main orchestrator for the minimap UI and its managers.&#10;public class MinimapUI&#10;{&#10;    // --- Managers and Content ---&#10;    // Handles map content (image, grid, static markers)&#10;    private MinimapContent minimapContent;&#10;    // Handles player marker and direction indicator&#10;    private PlayerMarkerManager playerMarkerManager;&#10;    // Handles minimap time display&#10;    private MinimapTimeDisplay minimapTimeDisplay;&#10;&#10;    // --- UI GameObjects ---&#10;    private GameObject minimapObject;           // Root object for the minimap UI&#10;    private GameObject minimapDisplayObject;    // The mask object for the minimap&#10;    private RectTransform minimapFrameRect;     // The frame (positioned in the corner)&#10;&#10;    // --- State ---&#10;    private readonly MapPreferences mapPreferences;&#10;    private bool initialized = false;&#10;    &#10;    // --- Scaled sizes (calculated at runtime) ---&#10;    private float scaledMinimapSize;&#10;    private float scaledMapContentSize;&#10;    private Image minimapMaskImage; // Cache for regenerating mask sprite&#10;&#10;    // --- Cached Player Reference ---&#10;    private Player playerObject;&#10;&#10;    // Handles contract PoI markers&#10;    private ContractMarkerManager ContractMarkerManager { get; set; }&#10;&#10;    private bool TimeBarEnabled =&gt; mapPreferences.ShowGameTime.Value;&#10;    private bool MinimapEnabled =&gt; mapPreferences.MinimapEnabled.Value;&#10;&#10;    // Dynamic world-to-minimap scale reflecting user preference.&#10;    private float CurrentWorldScale =&gt; Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;&#10;    public MinimapUI(MapPreferences preferences)&#10;    {&#10;        mapPreferences = preferences;&#10;        mapPreferences.MinimapEnabled.OnEntryValueChanged.Subscribe(OnMinimapEnableChanged);&#10;        mapPreferences.ShowGameTime.OnEntryValueChanged.Subscribe(OnTimeBarEnableChanged);&#10;        mapPreferences.IncreaseSize.OnEntryValueChanged.Subscribe(OnIncreaseSizeChanged);&#10;        RecalculateScaledSizes();&#10;    }&#10;    &#10;    private void RecalculateScaledSizes()&#10;    {&#10;        var scale = mapPreferences.MinimapScaleFactor;&#10;        scaledMinimapSize = Constants.BaseMinimapSize * scale;&#10;        scaledMapContentSize = Constants.BaseMapContentSize * scale;&#10;    }&#10;    &#10;    private void OnIncreaseSizeChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (!initialized) return;&#10;        RecalculateScaledSizes();&#10;        UpdateMinimapSize(true); // regenerate mask sprite&#10;&#10;        // Update scale in ContractMarkerManager&#10;        var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;        ContractMarkerManager?.UpdateMapScale(currentScale);&#10;        &#10;        // Reproject all PoI markers using new scale&#10;        MinimapPoIHelper.UpdateAllMarkerPositions(CurrentWorldScale);&#10;        // Immediately recenter content so player marker remains centered after size jump&#10;        UpdateMinimap();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes the minimap UI and starts integration and update coroutines.&#10;    /// &lt;/summary&gt;&#10;    public void Initialize()&#10;    {&#10;        if (!MinimapEnabled) return;&#10;        CreateMinimapDisplay();&#10;        StartSceneIntegration();    // Finds map sprite, player, and sets up markers&#10;        StartMinimapUpdateLoop();   // Continuously updates minimap as player moves&#10;        initialized = true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cleans up the minimap UI when the scene changes or mod is unloaded.&#10;    /// &lt;/summary&gt;&#10;    public void Dispose()&#10;    {&#10;        if (minimapObject == null) return;&#10;        UnityEngine.Object.Destroy(minimapObject);&#10;        minimapObject = null;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates the minimap UI hierarchy, including mask, background, content, and managers.&#10;    /// &lt;/summary&gt;&#10;    private void CreateMinimapDisplay()&#10;    {&#10;        RecalculateScaledSizes();&#10;        &#10;        // Root container for minimap UI&#10;        minimapObject = new GameObject(&quot;MinimapContainer&quot;);&#10;        UnityEngine.Object.DontDestroyOnLoad(minimapObject);&#10;&#10;        // Canvas for UI rendering&#10;        var canvasObject = MinimapUIFactory.CreateCanvas(minimapObject);&#10;&#10;        // Frame (positions minimap in the corner)&#10;        var (frameObject, frameRect) = MinimapUIFactory.CreateFrame(canvasObject, scaledMinimapSize);&#10;        minimapFrameRect = frameRect;&#10;&#10;        // Mask (circular area for minimap)&#10;        var (maskObject, maskImage) = MinimapUIFactory.CreateMask(frameObject, scaledMinimapSize);&#10;        minimapDisplayObject = maskObject;&#10;        minimapMaskImage = maskImage;&#10;&#10;        // Map content (holds the map image, grid, and markers)&#10;        minimapContent = new MinimapContent(&#10;            scaledMapContentSize, &#10;            20, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor);&#10;        minimapContent.Create(maskObject);&#10;        TryApplyMapSprite(); // Try to assign the map image immediately&#10;&#10;        // Player marker (centered in the minimap)&#10;        playerMarkerManager = new PlayerMarkerManager();&#10;        playerMarkerManager.CreatePlayerMarker(maskObject);&#10;&#10;        // Contract PoI markers&#10;        ContractMarkerManager = new ContractMarkerManager(&#10;            minimapContent, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor, &#10;            Constants.ContractMarkerXOffset, &#10;            Constants.ContractMarkerZOffset,&#10;            mapPreferences);&#10;&#10;        // Time display (shows in-game time)&#10;        minimapTimeDisplay = new MinimapTimeDisplay();&#10;        minimapTimeDisplay.Create(minimapFrameRect, mapPreferences.ShowGameTime);&#10;    }&#10;&#10;    private void OnMinimapEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;&#10;        if (newValue &amp;&amp; !initialized)&#10;        {&#10;            Initialize();&#10;        }&#10;&#10;        if (oldValue == newValue) return;&#10;        if (minimapDisplayObject != null)&#10;            minimapDisplayObject.SetActive(MinimapEnabled);&#10;&#10;        if (MinimapEnabled)&#10;        {&#10;            UpdateMinimapSize();&#10;        }&#10;&#10;        minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;    }&#10;&#10;    private void OnTimeBarEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (oldValue != newValue)&#10;        {&#10;            minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap and its elements when the size changes (e.g., 2x toggle).&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimapSize(bool regenerateMaskSprite = false)&#10;    {&#10;        RecalculateScaledSizes();&#10;&#10;        if (minimapFrameRect != null)&#10;            minimapFrameRect.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;&#10;        if (minimapDisplayObject != null)&#10;        {&#10;            var component = minimapDisplayObject.GetComponent&lt;RectTransform&gt;();&#10;            component.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;            &#10;            if (regenerateMaskSprite &amp;&amp; minimapMaskImage != null)&#10;                minimapMaskImage.sprite = MinimapUIFactory.CreateCircleSprite((int)scaledMinimapSize, Color.black);&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null) return;&#10;        var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentRect != null)&#10;            contentRect.sizeDelta = new Vector2(scaledMapContentSize, scaledMapContentSize);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to find and assign the map sprite from the game's UI to the minimap.&#10;    /// &lt;/summary&gt;&#10;    private void TryApplyMapSprite()&#10;    {&#10;        &#10;        var contentGo = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        Image contentImage = null;&#10;        if (contentGo != null)&#10;        {&#10;            contentImage = contentGo.GetComponent&lt;Image&gt;();&#10;            if (contentImage == null &amp;&amp; contentGo.transform.childCount &gt; 0)&#10;                contentImage = contentGo.transform.GetChild(0).GetComponent&lt;Image&gt;();&#10;        }&#10;&#10;        if (contentImage != null &amp;&amp; minimapContent != null)&#10;        {&#10;            var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;            if (minimapImage == null)&#10;                minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;&#10;            minimapImage.sprite = contentImage.sprite;&#10;            minimapImage.type = Image.Type.Simple;&#10;            minimapImage.preserveAspect = true;&#10;            minimapImage.enabled = true;&#10;            MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap.&quot;);&#10;        }&#10;        else&#10;        {&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find map sprite to apply to minimap.&quot;);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that integrates the minimap with the scene (finds player, map, markers).&#10;    /// &lt;/summary&gt;&#10;    private void StartSceneIntegration()&#10;    {&#10;        MelonCoroutines.Start(SceneIntegrationRoutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that finds the player, map sprite, and sets up markers after the scene loads.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator SceneIntegrationRoutine()&#10;    {&#10;        MelonLogger.Msg(&quot;MinimapUI: Looking for game objects...&quot;);&#10;&#10;        yield return new WaitForSeconds(2f);&#10;&#10;        GameObject mapAppObject = null;&#10;        GameObject viewportObject = null;&#10;&#10;        var attempts = 0;&#10;        while ((mapAppObject == null || playerObject == null) &amp;&amp; attempts &lt; 30)&#10;        {&#10;            attempts++;&#10;&#10;            // Find player by looking for a CharacterController not at world origin&#10;            playerObject ??= Player.Local;&#10;&#10;            // Find the MapApp UI object&#10;            if (mapAppObject == null)&#10;            {&#10;                var gameplayMenu = GameObject.Find(&quot;GameplayMenu&quot;);&#10;                if (gameplayMenu != null)&#10;                {&#10;                    var phoneTransform = gameplayMenu.transform.Find(&quot;Phone&quot;);&#10;                    if (phoneTransform != null)&#10;                    {&#10;                        var phoneChildTransform = phoneTransform.Find(&quot;phone&quot;);&#10;                        if (phoneChildTransform != null)&#10;                        {&#10;                            var appsCanvas = phoneChildTransform.Find(&quot;AppsCanvas&quot;);&#10;                            if (appsCanvas != null)&#10;                            {&#10;                                var mapApp = appsCanvas.Find(&quot;MapApp&quot;);&#10;                                if (mapApp != null)&#10;                                {&#10;                                    mapAppObject = mapApp.gameObject;&#10;                                    MelonLogger.Msg(&quot;MinimapUI: Found MapApp&quot;);&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Find the viewport (where the map image is)&#10;            if (mapAppObject != null &amp;&amp; viewportObject == null)&#10;            {&#10;                var container = mapAppObject.transform.Find(&quot;Container&quot;);&#10;                if (container != null)&#10;                {&#10;                    var scrollView = container.Find(&quot;Scroll View&quot;);&#10;                    if (scrollView != null)&#10;                    {&#10;                        var viewport = scrollView.Find(&quot;Viewport&quot;);&#10;                        if (viewport != null)&#10;                        {&#10;                            viewportObject = viewport.gameObject;&#10;                            MelonLogger.Msg(&quot;MinimapUI: Found Map Viewport&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (mapAppObject == null || playerObject == null)&#10;                yield return new WaitForSeconds(Constants.SceneIntegrationRetryDelay);&#10;        }&#10;&#10;        if (mapAppObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Map App after multiple attempts&quot;);&#10;        else if (viewportObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Found MapApp but could not find Viewport&quot;);&#10;        if (playerObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Player after multiple attempts&quot;);&#10;&#10;        MelonLogger.Msg(&quot;MinimapUI: Game object search completed&quot;);&#10;&#10;        // Apply map sprite from the viewport's content image&#10;        if (viewportObject != null)&#10;        {&#10;            try&#10;            {&#10;                if (viewportObject.transform.childCount &gt; 0)&#10;                {&#10;                    var contentTransform = viewportObject.transform.GetChild(0);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Found viewport content: &quot; + contentTransform.name);&#10;                    var contentImage = contentTransform.GetComponent&lt;Image&gt;();&#10;&#10;                    if (contentImage != null &amp;&amp; contentImage.sprite != null)&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Found content image with sprite: &quot; + contentImage.sprite.name);&#10;&#10;                        var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                        if (minimapImage == null)&#10;                            minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                        minimapImage.sprite = contentImage.sprite;&#10;                        minimapImage.type = Image.Type.Simple;&#10;                        minimapImage.preserveAspect = true;&#10;                        minimapImage.enabled = true;&#10;                        MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                        if (minimapContent.GridContainer != null)&#10;                            minimapContent.GridContainer.gameObject.SetActive(false);&#10;                    }&#10;                    else&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Content doesn't have an Image component or sprite&quot;);&#10;                        // Try children for a valid image&#10;                        var childCount = contentTransform.childCount;&#10;                        for (var i = 0; i &lt; childCount; i++)&#10;                        {&#10;                            var child = contentTransform.GetChild(i);&#10;                            var childImage = child.GetComponent&lt;Image&gt;();&#10;                            if (childImage != null &amp;&amp; childImage.sprite != null)&#10;                            {&#10;                                MelonLogger.Msg(&quot;MinimapUI: Found image in content child: &quot; + child.name + &quot;, Sprite: &quot; + childImage.sprite.name);&#10;&#10;                                var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                                if (minimapImage == null)&#10;                                    minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                                minimapImage.sprite = childImage.sprite;&#10;                                minimapImage.type = Image.Type.Simple;&#10;                                minimapImage.preserveAspect = true;&#10;                                minimapImage.enabled = true;&#10;                                MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                                if (minimapContent.GridContainer != null)&#10;                                    minimapContent.GridContainer.gameObject.SetActive(false);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;MinimapUI: Error accessing map content: &quot; + ex.Message);&#10;            }&#10;        }&#10;&#10;        // Replace fallback player marker with real icon if available&#10;        var cachedMapContent = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        if (cachedMapContent != null)&#10;        {&#10;            var playerPoI = cachedMapContent.transform.Find(&quot;PlayerPoI(Clone)&quot;);&#10;            if (playerPoI != null)&#10;            {&#10;                var realIcon = playerPoI.Find(&quot;IconContainer&quot;);&#10;                if (realIcon != null)&#10;                {&#10;                    playerMarkerManager.ReplaceWithRealPlayerIcon(realIcon.gameObject);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Replaced fallback player marker with real player icon.&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add default static markers if possible&#10;        if (cachedMapContent != null)&#10;        {&#10;            var propertyPoI = cachedMapContent.transform.Find(&quot;PropertyPoI(Clone)&quot;);&#10;            if (propertyPoI == null) yield break;&#10;            &#10;            var iconContainer = propertyPoI.Find(&quot;IconContainer&quot;);&#10;            if (iconContainer == null) yield break;&#10;            &#10;            PropertyPoIManager.Initialize(minimapContent, iconContainer);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that updates the minimap every frame.&#10;    /// &lt;/summary&gt;&#10;    private void StartMinimapUpdateLoop()&#10;    {&#10;        MelonCoroutines.Start(MinimapUpdateLoopCoroutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that updates the minimap's content position and player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator MinimapUpdateLoopCoroutine()&#10;    {&#10;        while (true)&#10;        {&#10;            UpdateMinimap();&#10;            yield return null;&#10;        }&#10;        // ReSharper disable once IteratorNeverReturns&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap's content position to keep the player centered, and updates the player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimap()&#10;    {&#10;        if (playerObject == null)&#10;        {&#10;            playerObject = Player.Local;&#10;&#10;            if (playerObject == null)&#10;                return;&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null)&#10;            return;&#10;        &#10;        // Use dynamic world scale that reflects current minimap size preference&#10;        var worldScale = CurrentWorldScale;&#10;        var position = playerObject.Position;&#10;        var mappedX = -position.x * worldScale;&#10;        var mappedZ = -position.z * worldScale;&#10;        var minimapMask = minimapDisplayObject.transform.Find(&quot;MinimapMask&quot;);&#10;        var zero = Vector2.zero;&#10;&#10;        if (minimapMask != null)&#10;        {&#10;            var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;            if (contentRect != null)&#10;            {&#10;                var rect = contentRect.rect;&#10;                var halfWidth = rect.width * 0.5f;&#10;                contentRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                zero = new Vector2(halfWidth, rect.height * 0.5f);&#10;            }&#10;        }&#10;&#10;        // Position of the player marker on the minimap (offset scaled with map)&#10;        var scaleFactor = mapPreferences.MinimapScaleFactor;&#10;        var sizeVector = new Vector2(&#10;            Constants.PlayerMarkerOffsetX * scaleFactor, &#10;            Constants.PlayerMarkerOffsetZ * scaleFactor);&#10;        var heightVector = new Vector2(mappedX, mappedZ) + zero + sizeVector;&#10;&#10;        var contentObject = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentObject != null)&#10;        {&#10;            contentObject.anchoredPosition = Vector2.Lerp(&#10;                contentObject.anchoredPosition,&#10;                heightVector,&#10;                Time.deltaTime * Constants.MapContentLerpSpeed);&#10;&#10;            // Update player marker direction indicator&#10;            playerMarkerManager?.UpdateDirectionIndicator(playerObject.Transform);&#10;        }&#10;        &#10;        minimapTimeDisplay.UpdateMinimapTime();&#10;    }&#10;&#10;&#10;    internal void OnContractAccepted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.AddContractPoIMarkerWorld(contract);&#10;    }&#10;&#10;    internal void OnContractCompleted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.RemoveContractPoIMarkers(contract);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Small Corner Map.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Small Corner Map.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;    &lt;Nullable&gt;disable&lt;/Nullable&gt;&#10;    &lt;RootNamespace&gt;Small_Corner_Map&lt;/RootNamespace&gt;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;    &lt;!-- Syncing AssemblyVersion/FileVersion with Constants.ModVersion (2.1.0) --&gt;&#10;    &lt;AssemblyVersion&gt;2.1.0.0&lt;/AssemblyVersion&gt;&#10;    &lt;FileVersion&gt;2.1.0.0&lt;/FileVersion&gt;&#10;    &lt;!-- &lt;NeutralLanguage&gt;en-US&lt;/NeutralLanguage&gt; --&gt;&#10;    &lt;AssemblyName&gt;Small_Corner_Map&lt;/AssemblyName&gt;&#10;    &lt;Platforms&gt;AnyCPU;x64&lt;/Platforms&gt;&#10;    &lt;Configurations&gt;IL2CPP;Mono&lt;/Configurations&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;&#10;  &lt;ItemGroup Condition=&quot;'$(Configuration)' == 'IL2CPP'&quot;&gt;&#10;    &lt;Reference Include=&quot;Assembly-CSharp&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Assembly-CSharp.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;Il2CppFishNet.Runtime&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2CppFishNet.Runtime.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.InputLegacyModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.InputLegacyModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;0Harmony&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\0Harmony.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;Il2Cppmscorlib&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2Cppmscorlib.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.CoreModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.CoreModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.TextRenderingModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.TextRenderingModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.UI&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.UI.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.UIModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.UIModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;S1API&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\S1API.Il2Cpp.MelonLoader.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;Il2CppInterop.Runtime&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2CppInterop.Runtime.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;&#10;  &lt;ItemGroup Condition=&quot;'$(Configuration)' == 'Mono'&quot;&gt;&#10;    &lt;Reference Include=&quot;Assembly-CSharp&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\Assembly-CSharp.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;0Harmony&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\0Harmony.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;MelonLoader&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\MelonLoader.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;S1API&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\S1API.Mono.MelonLoader.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.CoreModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.CoreModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.TextRenderingModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.TextRenderingModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.UI&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.UI.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;UnityEngine.UIModule&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.UIModule.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;    &lt;Reference Include=&quot;FishNet.Runtime&quot;&gt;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\FishNet.Runtime.dll&lt;/HintPath&gt;&#10;    &lt;/Reference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;AllowUnsafeBlocks&gt;True&lt;/AllowUnsafeBlocks&gt;&#10;    &lt;EnableDefaultCompileItems&gt;false&lt;/EnableDefaultCompileItems&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Compile Include=&quot;Core.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Helpers\Constants.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Helpers\MapPreferences.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Helpers\MinimapPoIHelper.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Helpers\MinimapUIFactory.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Helpers\Utils.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\ContractMarkerManager.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\MinimapContent.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\MinimapTimeDisplay.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\MinimapUI.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\MultiplayerManager.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\PlayerMarkerManager.cs&quot; /&gt;&#10;    &lt;Compile Include=&quot;Main\PropertyPoIManager.cs&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;LavaGang.MelonLoader&quot; Version=&quot;0.7.0&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'IL2CPP'&quot;&gt;&#10;    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;&#10;    &lt;DefineConstants&gt;$(DefineConstants);IL2CPP&lt;/DefineConstants&gt;&#10;    &lt;TargetName&gt;Small_Corner_Map.Il2cpp&lt;/TargetName&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &#10;  &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'Mono'&quot;&gt;&#10;    &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;&#10;    &lt;DefineConstants&gt;$(DefineConstants);Mono&lt;/DefineConstants&gt;&#10;    &lt;TargetName&gt;Small_Corner_Map.Mono&lt;/TargetName&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &#10;  &lt;Target Name=&quot;PostBuild&quot; AfterTargets=&quot;PostBuildEvent&quot;&gt;&#10;    &lt;Exec Condition=&quot;$(Configuration) == 'Mono'&quot; Command=&quot;COPY &amp;quot;$(TargetPath)&amp;quot; &amp;quot;D:\SteamLibrary\steamapps\common\Schedule I\Mods&amp;quot;&quot; /&gt;&#10;    &lt;Exec Condition=&quot;$(Configuration) == 'IL2CPP'&quot; Command=&quot;COPY &amp;quot;$(TargetPath)&amp;quot; &amp;quot;D:\SteamLibrary\steamapps\common\Schedule I - IL2CPP\Mods&amp;quot;&quot; /&gt;&#10;  &lt;/Target&gt;&#10;&lt;/Project&gt;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#13;&#10;&#13;&#10;  &lt;PropertyGroup&gt;&#13;&#10;    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;&#13;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#13;&#10;    &lt;Nullable&gt;disable&lt;/Nullable&gt;&#13;&#10;    &lt;RootNamespace&gt;Small_Corner_Map&lt;/RootNamespace&gt;&#13;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#13;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#13;&#10;    &lt;!-- Syncing AssemblyVersion/FileVersion with Constants.ModVersion (2.1.0) --&gt;&#13;&#10;    &lt;AssemblyVersion&gt;2.1.0.0&lt;/AssemblyVersion&gt;&#13;&#10;    &lt;FileVersion&gt;2.1.0.0&lt;/FileVersion&gt;&#13;&#10;    &lt;!-- &lt;NeutralLanguage&gt;en-US&lt;/NeutralLanguage&gt; --&gt;&#13;&#10;    &lt;AssemblyName&gt;Small_Corner_Map&lt;/AssemblyName&gt;&#13;&#10;    &lt;Platforms&gt;AnyCPU;x64&lt;/Platforms&gt;&#13;&#10;    &lt;Configurations&gt;IL2CPP;Mono&lt;/Configurations&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;&#13;&#10;  &lt;ItemGroup Condition=&quot;'$(Configuration)' == 'IL2CPP'&quot;&gt;&#13;&#10;    &lt;Reference Include=&quot;Assembly-CSharp&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Assembly-CSharp.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;Il2CppFishNet.Runtime&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2CppFishNet.Runtime.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.InputLegacyModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.InputLegacyModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;0Harmony&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\0Harmony.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;Il2Cppmscorlib&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2Cppmscorlib.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.CoreModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.CoreModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.TextRenderingModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.TextRenderingModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.UI&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.UI.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.UIModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\UnityEngine.UIModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;S1API&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\S1API.Il2Cpp.MelonLoader.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;Il2CppInterop.Runtime&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\IL2CPP\Il2CppInterop.Runtime.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;&#13;&#10;  &lt;ItemGroup Condition=&quot;'$(Configuration)' == 'Mono'&quot;&gt;&#13;&#10;    &lt;Reference Include=&quot;Assembly-CSharp&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\Assembly-CSharp.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;0Harmony&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\0Harmony.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;MelonLoader&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\MelonLoader.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;S1API&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\S1API.Mono.MelonLoader.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.CoreModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.CoreModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.TextRenderingModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.TextRenderingModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.UI&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.UI.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;UnityEngine.UIModule&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\UnityEngine.UIModule.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;    &lt;Reference Include=&quot;FishNet.Runtime&quot;&gt;&#13;&#10;      &lt;HintPath&gt;..\..\Assemblies\Mono\FishNet.Runtime.dll&lt;/HintPath&gt;&#13;&#10;    &lt;/Reference&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;&#13;&#10;  &lt;PropertyGroup&gt;&#13;&#10;    &lt;AllowUnsafeBlocks&gt;True&lt;/AllowUnsafeBlocks&gt;&#13;&#10;    &lt;EnableDefaultCompileItems&gt;false&lt;/EnableDefaultCompileItems&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;Compile Include=&quot;Core.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Helpers\Constants.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Helpers\MapPreferences.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Helpers\MinimapPoIHelper.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Helpers\MinimapUIFactory.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Helpers\Utils.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\ContractMarkerManager.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\MinimapContent.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\MinimapTimeDisplay.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\MinimapUI.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\MultiplayerManager.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\PlayerMarkerManager.cs&quot; /&gt;&#13;&#10;    &lt;Compile Include=&quot;Main\PropertyPoIManager.cs&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;PackageReference Include=&quot;LavaGang.MelonLoader&quot; Version=&quot;0.7.0&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;  &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'IL2CPP'&quot;&gt;&#13;&#10;    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;&#13;&#10;    &lt;DefineConstants&gt;$(DefineConstants);IL2CPP&lt;/DefineConstants&gt;&#13;&#10;    &lt;TargetName&gt;Small_Corner_Map.Il2cpp&lt;/TargetName&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;  &#13;&#10;  &lt;PropertyGroup Condition=&quot;'$(Configuration)' == 'Mono'&quot;&gt;&#13;&#10;    &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;&#13;&#10;    &lt;DefineConstants&gt;$(DefineConstants);Mono&lt;/DefineConstants&gt;&#13;&#10;    &lt;TargetName&gt;Small_Corner_Map.Mono&lt;/TargetName&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;  &#13;&#10;  &lt;Target Name=&quot;PostBuild&quot; AfterTargets=&quot;PostBuildEvent&quot;&gt;&#13;&#10;    &lt;Exec Condition=&quot;$(Configuration) == 'Mono'&quot; Command=&quot;COPY &amp;quot;$(TargetPath)&amp;quot; &amp;quot;D:\SteamLibrary\steamapps\common\Schedule I\Mods&amp;quot;&quot; /&gt;&#13;&#10;    &lt;Exec Condition=&quot;$(Configuration) == 'IL2CPP'&quot; Command=&quot;COPY &amp;quot;$(TargetPath)&amp;quot; &amp;quot;D:\SteamLibrary\steamapps\common\Schedule I - IL2CPP\Mods&amp;quot;&quot; /&gt;&#13;&#10;  &lt;/Target&gt;&#13;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>