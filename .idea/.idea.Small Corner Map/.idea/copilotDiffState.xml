<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Helpers/Constants.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Helpers/Constants.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text;&#10;using System.Threading.Tasks;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    internal class Constants&#10;    {&#10;        // Mod Info&#10;        public const string ModVersion = &quot;2.0.0&quot;;&#10;        public const string ModName = &quot;Small Corner Map&quot;;&#10;        public const string ModAuthor = &quot;winzaar&quot;;&#10;        public const string GameName = &quot;Schedule I&quot;;&#10;        public const string GameDeveloper = &quot;TVGS&quot;;&#10;        &#10;        // Map Scaling&#10;        public const float DefaultMapScale = 1.2487098f;&#10;        &#10;        // Marker Offsets&#10;        public const float ContractMarkerXOffset = 12f;  // X offset for contract markers&#10;        public const float ContractMarkerZOffset = -3f;  // Z offset for contract markers&#10;        public const float PropertyMarkerXOffset = -12f; // Horizontal calibration for property markers&#10;        public const float PropertyMarkerZOffset = 0f;   // Vertical calibration for property markers&#10;        &#10;        // Minimap UI Sizing&#10;        public const float BaseMinimapSize = 150f;       // Base size of the minimap mask/frame&#10;        public const float BaseMapContentSize = 500f;    // Base size of the map content&#10;        public const float MinimapCornerOffset = -20f;   // Distance from screen corner&#10;        &#10;        // Marker Sizing&#10;        public const float ContractMarkerSize = 15f;     // Width/height of contract markers&#10;        public const float ContractMarkerScale = 0.5f;   // Scale applied to contract markers&#10;        public const float PropertyMarkerSize = 10f;     // Width/height of property markers&#10;        public const float PropertyMarkerScale = 0.5f;   // Scale applied to property markers&#10;        public const float RedMarkerSize = 5f;           // Width/height of red debug markers&#10;        public const float PlayerMarkerSize = 10f;       // Width/height of player marker&#10;        public const float DirectionIndicatorSize = 6f;  // Width/height of direction indicator&#10;        public const float DirectionIndicatorDistance = 15f; // Distance from player marker center&#10;        &#10;        // Map Grid&#10;        public const int DefaultGridSize = 20;           // Grid divisions for map background&#10;        &#10;        // Canvas Settings&#10;        public const int CanvasSortOrder = 9999;         // Sort order for minimap canvas&#10;        public const float CanvasReferenceWidth = 1920f; // Reference resolution width&#10;        public const float CanvasReferenceHeight = 1080f; // Reference resolution height&#10;        &#10;        // Update &amp; Animation&#10;        public const float MapContentLerpSpeed = 10f;    // Smoothing speed for map panning&#10;        public const float PlayerMarkerOffsetX = 11.2f;  // Player marker horizontal centering offset&#10;        public const float PlayerMarkerOffsetZ = -2.7f;  // Player marker vertical centering offset&#10;        &#10;        // Time Display&#10;        public const float TimeDisplayWidth = 100f;      // Width of time display container&#10;        public const float TimeDisplayHeight = 50f;      // Height of time display container&#10;        public const float TimeDisplayOffsetY = 20f;     // Vertical offset from minimap&#10;        &#10;        // Colors (RGBA)&#10;        public const float TimeBackgroundR = 0.2f;       // Time display background red&#10;        public const float TimeBackgroundG = 0.2f;       // Time display background green&#10;        public const float TimeBackgroundB = 0.2f;       // Time display background blue&#10;        public const float TimeBackgroundA = 0.5f;       // Time display background alpha&#10;        public const float PlayerMarkerR = 0.2f;         // Player marker color red&#10;        public const float PlayerMarkerG = 0.6f;         // Player marker color green&#10;        public const float PlayerMarkerB = 1f;           // Player marker color blue&#10;        public const float PlayerMarkerA = 1f;           // Player marker color alpha&#10;        &#10;        // Player Icon Replacement Scale&#10;        public const float PlayerIconReplacementScale = 0.5f; // Scale applied when replacing player icon&#10;        &#10;        // Scene Integration&#10;        public const float SceneIntegrationInitialDelay = 2f;   // Wait before searching for game objects&#10;        public const float SceneIntegrationRetryDelay = 0.5f;   // Wait between search attempts&#10;        public const int SceneIntegrationMaxAttempts = 30;      // Max attempts to find game objects&#10;        &#10;        // GameObject Paths&#10;        public const string GameplayMenuPath = &quot;GameplayMenu&quot;;&#10;        public const string MapAppPath = &quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text;&#10;using System.Threading.Tasks;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    internal class Constants&#10;    {&#10;        // Mod Info&#10;        public const string ModVersion = &quot;2.0.0&quot;;&#10;        public const string ModName = &quot;Small Corner Map&quot;;&#10;        public const string ModAuthor = &quot;winzaar&quot;;&#10;        public const string GameName = &quot;Schedule I&quot;;&#10;        public const string GameDeveloper = &quot;TVGS&quot;;&#10;        &#10;        // Map Scaling&#10;        public const float DefaultMapScale = 1.2487098f;&#10;        &#10;        // Marker Offsets&#10;        public const float ContractMarkerXOffset = 12f;  // X offset for contract markers&#10;        public const float ContractMarkerZOffset = -3f;  // Z offset for contract markers&#10;        public const float PropertyMarkerXOffset = -12f; // Horizontal calibration for property markers&#10;        public const float PropertyMarkerZOffset = 0f;   // Vertical calibration for property markers&#10;        &#10;        // Minimap UI Sizing&#10;        public const float BaseMinimapSize = 150f;       // Base size of the minimap mask/frame&#10;        public const float BaseMapContentSize = 500f;    // Base size of the map content&#10;        public const float MinimapCornerOffset = -20f;   // Distance from screen corner&#10;        &#10;        // Marker Sizing&#10;        public const float ContractMarkerSize = 15f;     // Width/height of contract markers&#10;        public const float ContractMarkerScale = 0.5f;   // Scale applied to contract markers&#10;        public const float PropertyMarkerSize = 10f;     // Width/height of property markers&#10;        public const float PropertyMarkerScale = 0.5f;   // Scale applied to property markers&#10;        public const float RedMarkerSize = 5f;           // Width/height of red debug markers&#10;        public const float PlayerMarkerSize = 10f;       // Width/height of player marker&#10;        public const float DirectionIndicatorSize = 6f;  // Width/height of direction indicator&#10;        public const float DirectionIndicatorDistance = 15f; // Distance from player marker center&#10;        &#10;        // Map Grid&#10;        public const int DefaultGridSize = 20;           // Grid divisions for map background&#10;        &#10;        // Canvas Settings&#10;        public const int CanvasSortOrder = 9999;         // Sort order for minimap canvas&#10;        public const float CanvasReferenceWidth = 1920f; // Reference resolution width&#10;        public const float CanvasReferenceHeight = 1080f; // Reference resolution height&#10;        &#10;        // Update &amp; Animation&#10;        public const float MapContentLerpSpeed = 10f;    // Smoothing speed for map panning&#10;        public const float PlayerMarkerOffsetX = 11.2f;  // Player marker horizontal centering offset&#10;        public const float PlayerMarkerOffsetZ = -2.7f;  // Player marker vertical centering offset&#10;        &#10;        // Time Display&#10;        public const float TimeDisplayWidth = 100f;      // Width of time display container&#10;        public const float TimeDisplayHeight = 50f;      // Height of time display container&#10;        public const float TimeDisplayOffsetY = 20f;     // Vertical offset from minimap&#10;        &#10;        // Colors (RGBA)&#10;        public const float TimeBackgroundR = 0.2f;       // Time display background red&#10;        public const float TimeBackgroundG = 0.2f;       // Time display background green&#10;        public const float TimeBackgroundB = 0.2f;       // Time display background blue&#10;        public const float TimeBackgroundA = 0.5f;       // Time display background alpha&#10;        public const float PlayerMarkerR = 0.2f;         // Player marker color red&#10;        public const float PlayerMarkerG = 0.6f;         // Player marker color green&#10;        public const float PlayerMarkerB = 1f;           // Player marker color blue&#10;        public const float PlayerMarkerA = 1f;           // Player marker color alpha&#10;        &#10;        // Player Icon Replacement Scale&#10;        public const float PlayerIconReplacementScale = 0.5f; // Scale applied when replacing player icon&#10;        &#10;        // Scene Integration&#10;        public const float SceneIntegrationInitialDelay = 2f;   // Wait before searching for game objects&#10;        public const float SceneIntegrationRetryDelay = 0.5f;   // Wait between search attempts&#10;        public const int SceneIntegrationMaxAttempts = 30;      // Max attempts to find game objects&#10;        &#10;        // GameObject Paths&#10;        public const string GameplayMenuPath = &quot;GameplayMenu&quot;;&#10;        public const string MapAppPath = &quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Helpers/MinimapPoIHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Helpers/MinimapPoIHelper.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Small_Corner_Map.Main;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    public static class MinimapPoIHelper&#10;    {&#10;        // Single storage: name -&gt; entry containing GameObject + world data (IL2CPP-safe)&#10;        private struct MarkerEntry&#10;        {&#10;            public GameObject Marker;&#10;            public Vector3 WorldPos;&#10;            public float XOffset;&#10;            public float ZOffset;&#10;        }&#10;&#10;        private static readonly Dictionary&lt;string, MarkerEntry&gt; MarkerStore = new();&#10;&#10;        public static void AddWhitePoIMarker(MinimapContent minimapContent, Vector3 worldPos, GameObject iconPrefab)&#10;        {&#10;            var whiteMarker = minimapContent.AddWhiteStaticMarker(worldPos, iconPrefab);&#10;            if (whiteMarker == null) return;&#10;&#10;            var baseName = &quot;StaticMarker_White&quot;;&#10;            var uniqueName = baseName + &quot;_&quot; + worldPos.x.ToString(&quot;F2&quot;) + &quot;_&quot; + worldPos.z.ToString(&quot;F2&quot;);&#10;&#10;            RemoveMarker(uniqueName);&#10;&#10;            whiteMarker.name = uniqueName;&#10;            var rect = whiteMarker.GetComponent&lt;RectTransform&gt;();&#10;            if (rect != null)&#10;            {&#10;                // Apply calibration offsets on initial placement&#10;                rect.anchoredPosition += new Vector2(Constants.PropertyMarkerXOffset, Constants.PropertyMarkerZOffset);&#10;&#10;                MarkerStore[uniqueName] = new MarkerEntry&#10;                {&#10;                    Marker = whiteMarker,&#10;                    WorldPos = worldPos,&#10;                    XOffset = Constants.PropertyMarkerXOffset,&#10;                    ZOffset = Constants.PropertyMarkerZOffset&#10;                };&#10;                whiteMarker.transform.SetAsLastSibling();&#10;                MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Added white static marker '&quot; + uniqueName + &quot;' at world &quot; + worldPos + &quot; (with offsets)&quot;);&#10;            }&#10;            else&#10;            {&#10;                UnityEngine.Object.Destroy(whiteMarker);&#10;            }&#10;        }&#10;&#10;        public static void AddRedPoIMarker(MinimapContent minimapContent, Vector3 worldPos)&#10;        {&#10;            minimapContent.AddRedStaticMarker(worldPos);&#10;        }&#10;&#10;        public static void UpdateMarkerPosition(string name, Vector2 mappedPosition)&#10;        {&#10;            if (!MarkerStore.TryGetValue(name, out var entry)) return;&#10;            if (entry.Marker == null)&#10;            {&#10;                MarkerStore.Remove(name);&#10;                return;&#10;            }&#10;            var rect = entry.Marker.GetComponent&lt;RectTransform&gt;();&#10;            if (rect != null)&#10;                rect.anchoredPosition = mappedPosition;&#10;        }&#10;&#10;        public static void UpdateAllMarkerPositions(float mapScale)&#10;        {&#10;            // Recalculate positions for all stored markers&#10;            foreach (var (name, entry) in MarkerStore.ToList())&#10;            {&#10;                if (entry.Marker == null)&#10;                {&#10;                    MarkerStore.Remove(name);&#10;                    continue;&#10;                }&#10;                var x = entry.WorldPos.x * mapScale + entry.XOffset;&#10;                var z = entry.WorldPos.z * mapScale + entry.ZOffset;&#10;                var mapped = new Vector2(x, z);&#10;                var rect = entry.Marker.GetComponent&lt;RectTransform&gt;();&#10;                if (rect != null)&#10;                    rect.anchoredPosition = mapped;&#10;            }&#10;        }&#10;&#10;        public static void AddMarkersToMap(&#10;            GameObject markerPrefab,&#10;            GameObject mapContentObject,&#10;            string name,&#10;            Vector2 mappedPosition,&#10;            Vector3 worldPos,&#10;            float xOffset = 0f,&#10;            float zOffset = 0f)&#10;        {&#10;            // Remove existing marker with same name&#10;            RemoveMarker(name);&#10;            var markerObject = UnityEngine.Object.Instantiate(markerPrefab, mapContentObject.transform, false);&#10;            markerObject.name = name;&#10;            var rect = markerObject.GetComponent&lt;RectTransform&gt;();&#10;            if (rect == null)&#10;            {&#10;                UnityEngine.Object.Destroy(markerObject);&#10;                return;&#10;            }&#10;            var finalPos = mappedPosition + new Vector2(xOffset, zOffset);&#10;            rect.sizeDelta = new Vector2(Constants.ContractMarkerSize, Constants.ContractMarkerSize);&#10;            rect.anchoredPosition = finalPos;&#10;            markerObject.transform.localScale = new Vector3(Constants.ContractMarkerScale, Constants.ContractMarkerScale, Constants.ContractMarkerScale);&#10;            markerObject.transform.SetAsLastSibling();&#10;&#10;            MarkerStore[name] = new MarkerEntry&#10;            {&#10;                Marker = markerObject,&#10;                WorldPos = worldPos,&#10;                XOffset = xOffset,&#10;                ZOffset = zOffset&#10;            };&#10;&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Added marker '&quot; + name + &quot;' world=&quot; + worldPos + &quot; mapped=&quot; + finalPos + &quot; (offsets &quot; + xOffset + &quot;,&quot; + zOffset + &quot;)&quot;);&#10;        }&#10;&#10;        public static void RemoveMarker(string name)&#10;        {&#10;            if (!MarkerStore.TryGetValue(name, out var entry)) return;&#10;            if (entry.Marker != null)&#10;                UnityEngine.Object.Destroy(entry.Marker);&#10;            MarkerStore.Remove(name);&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Removed marker '&quot; + name + &quot;'&quot;);&#10;        }&#10;&#10;        public static void RemoveAllByKey(string key)&#10;        {&#10;            var toRemove = MarkerStore.Keys.Where(k =&gt; k.StartsWith(key)).ToList();&#10;            foreach (var k in toRemove)&#10;            {&#10;                var entry = MarkerStore[k];&#10;                if (entry.Marker != null)&#10;                    UnityEngine.Object.Destroy(entry.Marker);&#10;                MarkerStore.Remove(k);&#10;            }&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Removed &quot; + toRemove.Count + &quot; markers with key prefix '&quot; + key + &quot;'&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Small_Corner_Map.Main;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    public static class MinimapPoIHelper&#10;    {&#10;        // Single storage: name -&gt; entry containing GameObject + world data (IL2CPP-safe)&#10;        private struct MarkerEntry&#10;        {&#10;            public GameObject Marker;&#10;            public Vector3 WorldPos;&#10;            public float XOffset;&#10;            public float ZOffset;&#10;        }&#10;&#10;        private static readonly Dictionary&lt;string, MarkerEntry&gt; MarkerStore = new();&#10;&#10;        public static void AddWhitePoIMarker(MinimapContent minimapContent, Vector3 worldPos, GameObject iconPrefab)&#10;        {&#10;            var whiteMarker = minimapContent.AddWhiteStaticMarker(worldPos, iconPrefab);&#10;            if (whiteMarker == null) return;&#10;&#10;            var baseName = &quot;StaticMarker_White&quot;;&#10;            var uniqueName = baseName + &quot;_&quot; + worldPos.x.ToString(&quot;F2&quot;) + &quot;_&quot; + worldPos.z.ToString(&quot;F2&quot;);&#10;&#10;            RemoveMarker(uniqueName);&#10;&#10;            whiteMarker.name = uniqueName;&#10;            var rect = whiteMarker.GetComponent&lt;RectTransform&gt;();&#10;            if (rect != null)&#10;            {&#10;                // Apply calibration offsets on initial placement&#10;                rect.anchoredPosition += new Vector2(Constants.PropertyMarkerXOffset, Constants.PropertyMarkerZOffset);&#10;&#10;                MarkerStore[uniqueName] = new MarkerEntry&#10;                {&#10;                    Marker = whiteMarker,&#10;                    WorldPos = worldPos,&#10;                    XOffset = Constants.PropertyMarkerXOffset,&#10;                    ZOffset = Constants.PropertyMarkerZOffset&#10;                };&#10;                whiteMarker.transform.SetAsLastSibling();&#10;                MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Added white static marker '&quot; + uniqueName + &quot;' at world &quot; + worldPos + &quot; (with offsets)&quot;);&#10;            }&#10;            else&#10;            {&#10;                UnityEngine.Object.Destroy(whiteMarker);&#10;            }&#10;        }&#10;&#10;        public static void AddRedPoIMarker(MinimapContent minimapContent, Vector3 worldPos)&#10;        {&#10;            minimapContent.AddRedStaticMarker(worldPos);&#10;        }&#10;&#10;        public static void UpdateMarkerPosition(string name, Vector2 mappedPosition)&#10;        {&#10;            if (!MarkerStore.TryGetValue(name, out var entry)) return;&#10;            if (entry.Marker == null)&#10;            {&#10;                MarkerStore.Remove(name);&#10;                return;&#10;            }&#10;            var rect = entry.Marker.GetComponent&lt;RectTransform&gt;();&#10;            if (rect != null)&#10;                rect.anchoredPosition = mappedPosition;&#10;        }&#10;&#10;        public static void UpdateAllMarkerPositions(float mapScale)&#10;        {&#10;            // Recalculate positions for all stored markers&#10;            foreach (var (name, entry) in MarkerStore.ToList())&#10;            {&#10;                if (entry.Marker == null)&#10;                {&#10;                    MarkerStore.Remove(name);&#10;                    continue;&#10;                }&#10;                var x = entry.WorldPos.x * mapScale + entry.XOffset;&#10;                var z = entry.WorldPos.z * mapScale + entry.ZOffset;&#10;                var mapped = new Vector2(x, z);&#10;                var rect = entry.Marker.GetComponent&lt;RectTransform&gt;();&#10;                if (rect != null)&#10;                    rect.anchoredPosition = mapped;&#10;            }&#10;        }&#10;&#10;        public static void AddMarkersToMap(&#10;            GameObject markerPrefab,&#10;            GameObject mapContentObject,&#10;            string name,&#10;            Vector2 mappedPosition,&#10;            Vector3 worldPos,&#10;            float xOffset = 0f,&#10;            float zOffset = 0f)&#10;        {&#10;            // Remove existing marker with same name&#10;            RemoveMarker(name);&#10;            var markerObject = UnityEngine.Object.Instantiate(markerPrefab, mapContentObject.transform, false);&#10;            markerObject.name = name;&#10;            var rect = markerObject.GetComponent&lt;RectTransform&gt;();&#10;            if (rect == null)&#10;            {&#10;                UnityEngine.Object.Destroy(markerObject);&#10;                return;&#10;            }&#10;            var finalPos = mappedPosition + new Vector2(xOffset, zOffset);&#10;            rect.sizeDelta = new Vector2(Constants.ContractMarkerSize, Constants.ContractMarkerSize);&#10;            rect.anchoredPosition = finalPos;&#10;            markerObject.transform.localScale = new Vector3(Constants.ContractMarkerScale, Constants.ContractMarkerScale, Constants.ContractMarkerScale);&#10;            markerObject.transform.SetAsLastSibling();&#10;&#10;            MarkerStore[name] = new MarkerEntry&#10;            {&#10;                Marker = markerObject,&#10;                WorldPos = worldPos,&#10;                XOffset = xOffset,&#10;                ZOffset = zOffset&#10;            };&#10;&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Added marker '&quot; + name + &quot;' world=&quot; + worldPos + &quot; mapped=&quot; + finalPos + &quot; (offsets &quot; + xOffset + &quot;,&quot; + zOffset + &quot;)&quot;);&#10;        }&#10;&#10;        public static void RemoveMarker(string name)&#10;        {&#10;            if (!MarkerStore.TryGetValue(name, out var entry)) return;&#10;            if (entry.Marker != null)&#10;                UnityEngine.Object.Destroy(entry.Marker);&#10;            MarkerStore.Remove(name);&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Removed marker '&quot; + name + &quot;'&quot;);&#10;        }&#10;&#10;        public static void RemoveAllByKey(string key)&#10;        {&#10;            var toRemove = MarkerStore.Keys.Where(k =&gt; k.StartsWith(key)).ToList();&#10;            foreach (var k in toRemove)&#10;            {&#10;                var entry = MarkerStore[k];&#10;                if (entry.Marker != null)&#10;                    UnityEngine.Object.Destroy(entry.Marker);&#10;                MarkerStore.Remove(k);&#10;            }&#10;            MelonLoader.MelonLogger.Msg(&quot;MinimapPoIHelper: Removed &quot; + toRemove.Count + &quot; markers with key prefix '&quot; + key + &quot;'&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Helpers/MinimapUIFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Helpers/MinimapUIFactory.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating minimap UI GameObjects.&#10;    /// &lt;/summary&gt;&#10;    public static class MinimapUIFactory&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Creates the root canvas for the minimap UI.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the canvas to.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created canvas GameObject.&lt;/returns&gt;&#10;        public static GameObject CreateCanvas(GameObject parent)&#10;        {&#10;            var canvasObject = new GameObject(&quot;MinimapCanvas&quot;);&#10;            canvasObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var canvas = canvasObject.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 9999;&#10;            &#10;            var canvasScaler = canvasObject.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;            canvasScaler.referenceResolution = new Vector2(1920f, 1080f);&#10;            &#10;            canvasObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;&#10;            return canvasObject;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap frame (positions minimap in the corner).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the frame to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the frame.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created frame GameObject and its RectTransform.&lt;/returns&gt;&#10;        public static (GameObject frameObject, RectTransform rectTransform) CreateFrame(GameObject parent, float size)&#10;        {&#10;            var frameObject = new GameObject(&quot;MinimapFrame&quot;);&#10;            frameObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var rectTransform = frameObject.AddComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(1f, 1f);&#10;            rectTransform.anchorMax = new Vector2(1f, 1f);&#10;            rectTransform.pivot = new Vector2(1f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(-20f, -20f);&#10;            rectTransform.sizeDelta = new Vector2(size, size);&#10;&#10;            return (frameObject, rectTransform);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap mask (circular area for minimap).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the mask to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the mask.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created mask GameObject and its Image component.&lt;/returns&gt;&#10;        public static (GameObject maskObject, Image maskImage) CreateMask(GameObject parent, float size)&#10;        {&#10;            var maskObject = new GameObject(&quot;MinimapMask&quot;);&#10;            maskObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var maskRect = maskObject.AddComponent&lt;RectTransform&gt;();&#10;            maskRect.sizeDelta = new Vector2(size, size);&#10;            maskRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            maskRect.pivot = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchoredPosition = Vector2.zero;&#10;            &#10;            maskObject.AddComponent&lt;Mask&gt;().showMaskGraphic = false;&#10;            &#10;            var maskImage = maskObject.AddComponent&lt;Image&gt;();&#10;            maskImage.sprite = CreateCircleSprite((int)size, Color.black);&#10;            maskImage.type = Image.Type.Sliced;&#10;            maskImage.color = Color.black;&#10;&#10;            return (maskObject, maskImage);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates a filled circle sprite for the minimap mask/background.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;diameter&quot;&gt;Diameter of the circle in pixels.&lt;/param&gt;&#10;        /// &lt;param name=&quot;color&quot;&gt;Color of the circle.&lt;/param&gt;&#10;        /// &lt;param name=&quot;resolutionMultiplier&quot;&gt;Resolution multiplier for higher quality.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created circle sprite.&lt;/returns&gt;&#10;        public static Sprite CreateCircleSprite(int diameter, Color color, int resolutionMultiplier = 1)&#10;        {&#10;            var texSize = diameter * resolutionMultiplier;&#10;            var texture = new Texture2D(texSize, texSize, TextureFormat.ARGB32, false)&#10;            {&#10;                filterMode = FilterMode.Bilinear&#10;            };&#10;            &#10;            var clear = new Color(0f, 0f, 0f, 0f);&#10;            for (var i = 0; i &lt; texSize; i++)&#10;                for (var j = 0; j &lt; texSize; j++)&#10;                    texture.SetPixel(j, i, clear);&#10;            &#10;            var radius = texSize / 2;&#10;            var center = new Vector2(radius, radius);&#10;            &#10;            for (var k = 0; k &lt; texSize; k++)&#10;                for (var l = 0; l &lt; texSize; l++)&#10;                    if (Vector2.Distance(new Vector2(l, k), center) &lt;= radius)&#10;                        texture.SetPixel(l, k, color);&#10;            &#10;            texture.Apply();&#10;            return Sprite.Create(texture, new Rect(0f, 0f, texSize, texSize), new Vector2(0.5f, 0.5f), resolutionMultiplier);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the player marker GameObject.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the marker to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;markerColor&quot;&gt;Color for the marker.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the marker.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created player marker GameObject.&lt;/returns&gt;&#10;        public static GameObject CreatePlayerMarker(GameObject parent, Color markerColor, float size = 10f)&#10;        {&#10;            var marker = new GameObject(&quot;PlayerMarker&quot;);&#10;            marker.transform.SetParent(parent.transform, false);&#10;            &#10;            var rect = marker.AddComponent&lt;RectTransform&gt;();&#10;            rect.sizeDelta = new Vector2(size, size);&#10;            rect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            rect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            rect.pivot = new Vector2(0.5f, 0.5f);&#10;            rect.anchoredPosition = Vector2.zero;&#10;            &#10;            var image = marker.AddComponent&lt;Image&gt;();&#10;            image.color = markerColor;&#10;&#10;            // Ensure player marker is drawn on top&#10;            marker.transform.SetAsLastSibling();&#10;&#10;            return marker;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the direction indicator for the player marker.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject (player marker) to attach the indicator to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;indicatorColor&quot;&gt;Color for the indicator.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the indicator.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created direction indicator RectTransform.&lt;/returns&gt;&#10;        public static RectTransform CreateDirectionIndicator(GameObject parent, Color indicatorColor, float size = Constants.DirectionIndicatorSize)&#10;        {&#10;            var indicatorObject = new GameObject(&quot;DirectionIndicator&quot;);&#10;            indicatorObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var directionIndicator = indicatorObject.AddComponent&lt;RectTransform&gt;();&#10;            directionIndicator.sizeDelta = new Vector2(size, size);&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            &#10;            var image = indicatorObject.AddComponent&lt;Image&gt;();&#10;            image.color = indicatorColor;&#10;&#10;            return directionIndicator;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Small_Corner_Map.Helpers&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating minimap UI GameObjects.&#10;    /// &lt;/summary&gt;&#10;    public static class MinimapUIFactory&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Creates the root canvas for the minimap UI.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the canvas to.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created canvas GameObject.&lt;/returns&gt;&#10;        public static GameObject CreateCanvas(GameObject parent)&#10;        {&#10;            var canvasObject = new GameObject(&quot;MinimapCanvas&quot;);&#10;            canvasObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var canvas = canvasObject.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 9999;&#10;            &#10;            var canvasScaler = canvasObject.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;            canvasScaler.referenceResolution = new Vector2(1920f, 1080f);&#10;            &#10;            canvasObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;&#10;            return canvasObject;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap frame (positions minimap in the corner).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the frame to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the frame.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created frame GameObject and its RectTransform.&lt;/returns&gt;&#10;        public static (GameObject frameObject, RectTransform rectTransform) CreateFrame(GameObject parent, float size)&#10;        {&#10;            var frameObject = new GameObject(&quot;MinimapFrame&quot;);&#10;            frameObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var rectTransform = frameObject.AddComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(1f, 1f);&#10;            rectTransform.anchorMax = new Vector2(1f, 1f);&#10;            rectTransform.pivot = new Vector2(1f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(-20f, -20f);&#10;            rectTransform.sizeDelta = new Vector2(size, size);&#10;&#10;            return (frameObject, rectTransform);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the minimap mask (circular area for minimap).&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the mask to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the mask.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created mask GameObject and its Image component.&lt;/returns&gt;&#10;        public static (GameObject maskObject, Image maskImage) CreateMask(GameObject parent, float size)&#10;        {&#10;            var maskObject = new GameObject(&quot;MinimapMask&quot;);&#10;            maskObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var maskRect = maskObject.AddComponent&lt;RectTransform&gt;();&#10;            maskRect.sizeDelta = new Vector2(size, size);&#10;            maskRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            maskRect.pivot = new Vector2(0.5f, 0.5f);&#10;            maskRect.anchoredPosition = Vector2.zero;&#10;            &#10;            maskObject.AddComponent&lt;Mask&gt;().showMaskGraphic = false;&#10;            &#10;            var maskImage = maskObject.AddComponent&lt;Image&gt;();&#10;            maskImage.sprite = CreateCircleSprite((int)size, Color.black);&#10;            maskImage.type = Image.Type.Sliced;&#10;            maskImage.color = Color.black;&#10;&#10;            return (maskObject, maskImage);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates a filled circle sprite for the minimap mask/background.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;diameter&quot;&gt;Diameter of the circle in pixels.&lt;/param&gt;&#10;        /// &lt;param name=&quot;color&quot;&gt;Color of the circle.&lt;/param&gt;&#10;        /// &lt;param name=&quot;resolutionMultiplier&quot;&gt;Resolution multiplier for higher quality.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created circle sprite.&lt;/returns&gt;&#10;        public static Sprite CreateCircleSprite(int diameter, Color color, int resolutionMultiplier = 1)&#10;        {&#10;            var texSize = diameter * resolutionMultiplier;&#10;            var texture = new Texture2D(texSize, texSize, TextureFormat.ARGB32, false)&#10;            {&#10;                filterMode = FilterMode.Bilinear&#10;            };&#10;            &#10;            var clear = new Color(0f, 0f, 0f, 0f);&#10;            for (var i = 0; i &lt; texSize; i++)&#10;                for (var j = 0; j &lt; texSize; j++)&#10;                    texture.SetPixel(j, i, clear);&#10;            &#10;            var radius = texSize / 2;&#10;            var center = new Vector2(radius, radius);&#10;            &#10;            for (var k = 0; k &lt; texSize; k++)&#10;                for (var l = 0; l &lt; texSize; l++)&#10;                    if (Vector2.Distance(new Vector2(l, k), center) &lt;= radius)&#10;                        texture.SetPixel(l, k, color);&#10;            &#10;            texture.Apply();&#10;            return Sprite.Create(texture, new Rect(0f, 0f, texSize, texSize), new Vector2(0.5f, 0.5f), resolutionMultiplier);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the player marker GameObject.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject to attach the marker to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;markerColor&quot;&gt;Color for the marker.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the marker.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created player marker GameObject.&lt;/returns&gt;&#10;        public static GameObject CreatePlayerMarker(GameObject parent, Color markerColor, float size = 10f)&#10;        {&#10;            var marker = new GameObject(&quot;PlayerMarker&quot;);&#10;            marker.transform.SetParent(parent.transform, false);&#10;            &#10;            var rect = marker.AddComponent&lt;RectTransform&gt;();&#10;            rect.sizeDelta = new Vector2(size, size);&#10;            rect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            rect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            rect.pivot = new Vector2(0.5f, 0.5f);&#10;            rect.anchoredPosition = Vector2.zero;&#10;            &#10;            var image = marker.AddComponent&lt;Image&gt;();&#10;            image.color = markerColor;&#10;&#10;            // Ensure player marker is drawn on top&#10;            marker.transform.SetAsLastSibling();&#10;&#10;            return marker;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Creates the direction indicator for the player marker.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;parent&quot;&gt;Parent GameObject (player marker) to attach the indicator to.&lt;/param&gt;&#10;        /// &lt;param name=&quot;indicatorColor&quot;&gt;Color for the indicator.&lt;/param&gt;&#10;        /// &lt;param name=&quot;size&quot;&gt;Size of the indicator.&lt;/param&gt;&#10;        /// &lt;returns&gt;The created direction indicator RectTransform.&lt;/returns&gt;&#10;        public static RectTransform CreateDirectionIndicator(GameObject parent, Color indicatorColor, float size = Constants.DirectionIndicatorSize)&#10;        {&#10;            var indicatorObject = new GameObject(&quot;DirectionIndicator&quot;);&#10;            indicatorObject.transform.SetParent(parent.transform, false);&#10;            &#10;            var directionIndicator = indicatorObject.AddComponent&lt;RectTransform&gt;();&#10;            directionIndicator.sizeDelta = new Vector2(size, size);&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            &#10;            var image = indicatorObject.AddComponent&lt;Image&gt;();&#10;            image.color = indicatorColor;&#10;&#10;            return directionIndicator;&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/ContractMarkerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/ContractMarkerManager.cs" />
              <option name="originalContent" value="#if IL2CPP&#10;using Il2CppScheduleOne.Economy;&#10;using Il2CppScheduleOne.Quests;&#10;#else&#10;using ScheduleOne.Economy;&#10;using ScheduleOne.Quests;&#10;#endif&#10;&#10;using HarmonyLib;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class ContractMarkerManager&#10;    {&#10;        private GameObject contractPoIIconPrefab;&#10;        private readonly float mapScale;&#10;        private readonly float markerXAdjustment;&#10;        private GameObject mapContentObject;&#10;        private MinimapContent mapContent;&#10;&#10;        private const string ContractPoIMarkerKey = &quot;ContractPoI_Marker&quot;;&#10;&#10;        public ContractMarkerManager(MinimapContent minimapContent, float mapScale, float markerXAdjustment, float markerZAdjustment)&#10;        {&#10;            this.mapContent = minimapContent;&#10;            this.mapContentObject = minimapContent.MapContentObject;&#10;            this.mapScale = mapScale;&#10;            this.markerXAdjustment = markerXAdjustment;&#10;        }&#10;&#10;        public void SetMapContentObject(GameObject mapContent)&#10;        {&#10;            mapContentObject = mapContent;&#10;        }&#10;&#10;        internal void AddContractPoIMarkerWorld(Contract contract)&#10;        {&#10;            if (contract == null || mapContentObject == null)&#10;                return;&#10;&#10;            Vector3 worldPos = contract.DeliveryLocation.CustomerStandPoint.position;&#10;            var xPosition = worldPos.x * mapScale;&#10;            var zPosition = worldPos.z * mapScale;&#10;            Vector2 mappedPos = new Vector2(xPosition, zPosition);&#10;&#10;            if (mapContentObject != null)&#10;            {&#10;                if (contractPoIIconPrefab == null)&#10;                {&#10;                    CacheContractPoIIcon(contract);&#10;                }&#10;&#10;                MinimapPoIHelper.AddMarkersToMap(&#10;                    contractPoIIconPrefab,&#10;                    mapContentObject,&#10;                    ContractPoIMarkerKey + &quot;_&quot; + contract.GUID,&#10;                    mappedPos,&#10;                    worldPos,&#10;                    -markerXAdjustment,&#10;                    0f);&#10;            }&#10;        }&#10;&#10;        internal void RemoveContractPoIMarkers(Contract contract)&#10;        {&#10;            var name = ContractPoIMarkerKey + &quot;_&quot; + contract.GUID;&#10;            MinimapPoIHelper.RemoveMarker(name);&#10;        }&#10;&#10;        internal void RemoveAllContractPoIMarkers()&#10;        {&#10;            MinimapPoIHelper.RemoveAllByKey(ContractPoIMarkerKey);&#10;        }&#10;&#10;        private void CacheContractPoIIcon(Contract contract)&#10;        {&#10;            contractPoIIconPrefab = contract.IconPrefab.gameObject;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#if IL2CPP&#10;using Il2CppScheduleOne.Economy;&#10;using Il2CppScheduleOne.Quests;&#10;#else&#10;using ScheduleOne.Economy;&#10;using ScheduleOne.Quests;&#10;#endif&#10;&#10;using HarmonyLib;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class ContractMarkerManager&#10;    {&#10;        private GameObject contractPoIIconPrefab;&#10;        private float mapScale;&#10;        private readonly float markerXAdjustment;&#10;        private GameObject mapContentObject;&#10;        private MinimapContent mapContent;&#10;        private readonly MapPreferences mapPreferences;&#10;&#10;        private const string ContractPoIMarkerKey = &quot;ContractPoI_Marker&quot;;&#10;&#10;        public ContractMarkerManager(MinimapContent minimapContent, float mapScale, float markerXAdjustment, float markerZAdjustment, MapPreferences preferences)&#10;        {&#10;            this.mapContent = minimapContent;&#10;            this.mapContentObject = minimapContent.MapContentObject;&#10;            this.mapScale = mapScale;&#10;            this.markerXAdjustment = markerXAdjustment;&#10;            this.mapPreferences = preferences;&#10;        }&#10;&#10;        public void SetMapContentObject(GameObject mapContent)&#10;        {&#10;            mapContentObject = mapContent;&#10;        }&#10;        &#10;        public void UpdateMapScale(float newMapScale)&#10;        {&#10;            mapScale = newMapScale;&#10;        }&#10;&#10;        internal void AddContractPoIMarkerWorld(Contract contract)&#10;        {&#10;            if (contract == null || mapContentObject == null)&#10;                return;&#10;&#10;            // Use current dynamic scale factor from preferences&#10;            var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;            &#10;            Vector3 worldPos = contract.DeliveryLocation.CustomerStandPoint.position;&#10;            var xPosition = worldPos.x * currentScale;&#10;            var zPosition = worldPos.z * currentScale;&#10;            Vector2 mappedPos = new Vector2(xPosition, zPosition);&#10;&#10;            if (mapContentObject != null)&#10;            {&#10;                if (contractPoIIconPrefab == null)&#10;                {&#10;                    CacheContractPoIIcon(contract);&#10;                }&#10;&#10;                MinimapPoIHelper.AddMarkersToMap(&#10;                    contractPoIIconPrefab,&#10;                    mapContentObject,&#10;                    ContractPoIMarkerKey + &quot;_&quot; + contract.GUID,&#10;                    mappedPos,&#10;                    worldPos,&#10;                    -markerXAdjustment,&#10;                    0f);&#10;            }&#10;        }&#10;&#10;        internal void RemoveContractPoIMarkers(Contract contract)&#10;        {&#10;            var name = ContractPoIMarkerKey + &quot;_&quot; + contract.GUID;&#10;            MinimapPoIHelper.RemoveMarker(name);&#10;        }&#10;&#10;        internal void RemoveAllContractPoIMarkers()&#10;        {&#10;            MinimapPoIHelper.RemoveAllByKey(ContractPoIMarkerKey);&#10;        }&#10;&#10;        private void CacheContractPoIIcon(Contract contract)&#10;        {&#10;            contractPoIIconPrefab = contract.IconPrefab.gameObject;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/MinimapContent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/MinimapContent.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using MelonLoader;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class MinimapContent&#10;    {&#10;        public GameObject MapContentObject { get; private set; }&#10;        public RectTransform GridContainer { get; private set; }&#10;&#10;        private readonly float mapContentSize;&#10;        private readonly int gridSize;&#10;        private readonly Color gridColor;&#10;        private readonly float mapScale;&#10;&#10;        public MinimapContent(float mapContentSize = 500f, int gridSize = 20, float mapScale = 1.2487098f, Color? gridColor = null)&#10;        {&#10;            this.mapContentSize = mapContentSize;&#10;            this.gridSize = gridSize;&#10;            this.mapScale = mapScale;&#10;            this.gridColor = gridColor ?? new Color(0.3f, 0.3f, 0.3f, 1f);&#10;        }&#10;&#10;        public void Create(GameObject parent)&#10;        {&#10;            MapContentObject = new GameObject(&quot;MapContent&quot;);&#10;            MapContentObject.transform.SetParent(parent.transform, false);&#10;            RectTransform mapContentRect = MapContentObject.AddComponent&lt;RectTransform&gt;();&#10;            mapContentRect.sizeDelta = new Vector2(mapContentSize, mapContentSize);&#10;            mapContentRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.pivot = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.anchoredPosition = Vector2.zero;&#10;&#10;            // Create grid container&#10;            GameObject gridObject = new GameObject(&quot;GridContainer&quot;);&#10;            gridObject.transform.SetParent(MapContentObject.transform, false);&#10;            GridContainer = gridObject.AddComponent&lt;RectTransform&gt;();&#10;            GridContainer.sizeDelta = new Vector2(mapContentSize, mapContentSize);&#10;            GridContainer.anchorMin = new Vector2(0.5f, 0.5f);&#10;            GridContainer.anchorMax = new Vector2(0.5f, 0.5f);&#10;            GridContainer.pivot = new Vector2(0.5f, 0.5f);&#10;            GridContainer.anchoredPosition = Vector2.zero;&#10;        }&#10;&#10;        public GameObject AddWhiteStaticMarker(Vector3 worldPos, GameObject iconPrefab)&#10;        {&#10;            if (MapContentObject == null || iconPrefab == null)&#10;            {&#10;                MelonLogger.Warning(&quot;MinimapContent: Cannot add white marker, missing map content or icon prefab.&quot;);&#10;                return null;&#10;            }&#10;&#10;            GameObject markerObject = UnityEngine.Object.Instantiate(iconPrefab);&#10;            markerObject.name = &quot;StaticMarker_White&quot;; // base name; helper may override for uniqueness&#10;            markerObject.transform.SetParent(MapContentObject.transform, false);&#10;            RectTransform markerRect = markerObject.GetComponent&lt;RectTransform&gt;();&#10;&#10;            if (markerRect != null)&#10;            {&#10;                markerRect.sizeDelta = new Vector2(10f, 10f);&#10;                float mappedX = worldPos.x * mapScale;&#10;                float mappedZ = worldPos.z * mapScale;&#10;                markerRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                markerObject.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);&#10;            }&#10;            return markerObject; // ensure a return even if markerRect was null&#10;        }&#10;&#10;        public void AddRedStaticMarker(Vector3 worldPos)&#10;        {&#10;            if (MapContentObject == null)&#10;            {&#10;                MelonLogger.Warning(&quot;MinimapContent: Cannot add red marker, missing map content.&quot;);&#10;                return;&#10;            }&#10;&#10;            GameObject markerObject = new GameObject(&quot;StaticMarker_Red&quot;);&#10;            markerObject.transform.SetParent(MapContentObject.transform, false);&#10;            RectTransform markerRect = markerObject.AddComponent&lt;RectTransform&gt;();&#10;            markerRect.sizeDelta = new Vector2(Constants.RedMarkerSize, Constants.RedMarkerSize);&#10;            float mappedX = worldPos.x * mapScale;&#10;            float mappedZ = worldPos.z * mapScale;&#10;            markerRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;            Image markerImage = markerObject.AddComponent&lt;Image&gt;();&#10;            markerImage.color = Color.red;&#10;            MelonLogger.Msg(&quot;Red static marker added at mapped position: &quot; + markerRect.anchoredPosition);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using MelonLoader;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class MinimapContent&#10;    {&#10;        public GameObject MapContentObject { get; private set; }&#10;        public RectTransform GridContainer { get; private set; }&#10;&#10;        private readonly float mapContentSize;&#10;        private readonly int gridSize;&#10;        private readonly Color gridColor;&#10;        private readonly float mapScale;&#10;&#10;        public MinimapContent(float mapContentSize = 500f, int gridSize = 20, float mapScale = 1.2487098f, Color? gridColor = null)&#10;        {&#10;            this.mapContentSize = mapContentSize;&#10;            this.gridSize = gridSize;&#10;            this.mapScale = mapScale;&#10;            this.gridColor = gridColor ?? new Color(0.3f, 0.3f, 0.3f, 1f);&#10;        }&#10;&#10;        public void Create(GameObject parent)&#10;        {&#10;            MapContentObject = new GameObject(&quot;MapContent&quot;);&#10;            MapContentObject.transform.SetParent(parent.transform, false);&#10;            RectTransform mapContentRect = MapContentObject.AddComponent&lt;RectTransform&gt;();&#10;            mapContentRect.sizeDelta = new Vector2(mapContentSize, mapContentSize);&#10;            mapContentRect.anchorMin = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.anchorMax = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.pivot = new Vector2(0.5f, 0.5f);&#10;            mapContentRect.anchoredPosition = Vector2.zero;&#10;&#10;            // Create grid container&#10;            GameObject gridObject = new GameObject(&quot;GridContainer&quot;);&#10;            gridObject.transform.SetParent(MapContentObject.transform, false);&#10;            GridContainer = gridObject.AddComponent&lt;RectTransform&gt;();&#10;            GridContainer.sizeDelta = new Vector2(mapContentSize, mapContentSize);&#10;            GridContainer.anchorMin = new Vector2(0.5f, 0.5f);&#10;            GridContainer.anchorMax = new Vector2(0.5f, 0.5f);&#10;            GridContainer.pivot = new Vector2(0.5f, 0.5f);&#10;            GridContainer.anchoredPosition = Vector2.zero;&#10;        }&#10;&#10;        public GameObject AddWhiteStaticMarker(Vector3 worldPos, GameObject iconPrefab)&#10;        {&#10;            if (MapContentObject == null || iconPrefab == null)&#10;            {&#10;                MelonLogger.Warning(&quot;MinimapContent: Cannot add white marker, missing map content or icon prefab.&quot;);&#10;                return null;&#10;            }&#10;&#10;            GameObject markerObject = UnityEngine.Object.Instantiate(iconPrefab);&#10;            markerObject.name = &quot;StaticMarker_White&quot;; // base name; helper may override for uniqueness&#10;            markerObject.transform.SetParent(MapContentObject.transform, false);&#10;            RectTransform markerRect = markerObject.GetComponent&lt;RectTransform&gt;();&#10;&#10;            if (markerRect != null)&#10;            {&#10;                markerRect.sizeDelta = new Vector2(10f, 10f);&#10;                float mappedX = worldPos.x * mapScale;&#10;                float mappedZ = worldPos.z * mapScale;&#10;                markerRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                markerObject.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);&#10;            }&#10;            return markerObject; // ensure a return even if markerRect was null&#10;        }&#10;&#10;        public void AddRedStaticMarker(Vector3 worldPos)&#10;        {&#10;            if (MapContentObject == null)&#10;            {&#10;                MelonLogger.Warning(&quot;MinimapContent: Cannot add red marker, missing map content.&quot;);&#10;                return;&#10;            }&#10;&#10;            GameObject markerObject = new GameObject(&quot;StaticMarker_Red&quot;);&#10;            markerObject.transform.SetParent(MapContentObject.transform, false);&#10;            RectTransform markerRect = markerObject.AddComponent&lt;RectTransform&gt;();&#10;            markerRect.sizeDelta = new Vector2(Constants.RedMarkerSize, Constants.RedMarkerSize);&#10;            float mappedX = worldPos.x * mapScale;&#10;            float mappedZ = worldPos.z * mapScale;&#10;            markerRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;            Image markerImage = markerObject.AddComponent&lt;Image&gt;();&#10;            markerImage.color = Color.red;&#10;            MelonLogger.Msg(&quot;Red static marker added at mapped position: &quot; + markerRect.anchoredPosition);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/MinimapTimeDisplay.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/MinimapTimeDisplay.cs" />
              <option name="originalContent" value="using MelonLoader;&#10;using S1API.GameTime;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class MinimapTimeDisplay&#10;    {&#10;        private RectTransform minimapTimeContainer;&#10;        private Text minimapTimeText;&#10;        private MelonPreferences_Entry&lt;bool&gt; timeBarEnabled;&#10;&#10;        public RectTransform Container =&gt; minimapTimeContainer;&#10;        public Text TimeText =&gt; minimapTimeText;&#10;&#10;        private bool enabled { get { return timeBarEnabled.Value; } }&#10;&#10;        public void Create(Transform parent, MelonPreferences_Entry&lt;bool&gt; enabled)&#10;        {&#10;            timeBarEnabled = enabled;&#10;            GameObject containerObject = new GameObject(&quot;MinimapTimeContainer&quot;);&#10;            containerObject.transform.SetParent(parent, false);&#10;&#10;            minimapTimeContainer = containerObject.AddComponent&lt;RectTransform&gt;();&#10;            minimapTimeContainer.sizeDelta = new Vector2(Constants.TimeDisplayWidth, Constants.TimeDisplayHeight);&#10;            minimapTimeContainer.anchorMin = new Vector2(0.5f, 0f);&#10;            minimapTimeContainer.anchorMax = new Vector2(0.5f, 0f);&#10;            minimapTimeContainer.pivot = new Vector2(0.5f, 1f);&#10;&#10;            minimapTimeContainer.anchoredPosition = new Vector2(0f, Constants.TimeDisplayOffsetY);&#10;&#10;            Image backgroundImage = containerObject.AddComponent&lt;Image&gt;();&#10;            backgroundImage.color = new Color(&#10;                Constants.TimeBackgroundR, &#10;                Constants.TimeBackgroundG, &#10;                Constants.TimeBackgroundB, &#10;                Constants.TimeBackgroundA);&#10;&#10;            GameObject timeTextObject = new GameObject(&quot;MinimapTime&quot;);&#10;            timeTextObject.transform.SetParent(containerObject.transform, false);&#10;&#10;            RectTransform timeTextRect = timeTextObject.AddComponent&lt;RectTransform&gt;();&#10;            timeTextRect.anchorMin = new Vector2(0f, 0f);&#10;            timeTextRect.anchorMax = new Vector2(1f, 1f);&#10;            timeTextRect.anchoredPosition = Vector2.zero;&#10;&#10;            minimapTimeText = timeTextObject.AddComponent&lt;Text&gt;();&#10;            minimapTimeText.font = Resources.GetBuiltinResource&lt;Font&gt;(&quot;Arial.ttf&quot;);&#10;            minimapTimeText.fontSize = 16;&#10;            minimapTimeText.color = Color.white;&#10;            minimapTimeText.alignment = TextAnchor.MiddleCenter;&#10;            minimapTimeText.text = minimapTimeText.text ?? &quot;00:00:00&quot;;&#10;            minimapTimeText.raycastTarget = false;&#10;&#10;            if (!this.enabled)&#10;            {&#10;                containerObject.SetActive(false);&#10;            }&#10;        }&#10;&#10;        public void SetTimeBarEnabled(bool enabled)&#10;        {&#10;            timeBarEnabled.Value = enabled;&#10;            if (minimapTimeContainer != null)&#10;                minimapTimeContainer.gameObject.SetActive(enabled);&#10;        }&#10;&#10;        public void UpdateMinimapTime()&#10;        {&#10;            try&#10;            {&#10;                var currentTime = TimeManager.GetFormatted12HourTime();&#10;                var currentDay = TimeManager.CurrentDay;&#10;                if (minimapTimeText != null &amp;&amp; currentTime != null)&#10;                {&#10;                    minimapTimeText.text = currentDay.ToString() + &quot;\n&quot; + currentTime;&#10;                }&#10;            }&#10;            catch (System.Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;Error updating minimap time: &quot; + ex.Message);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using MelonLoader;&#10;using S1API.GameTime;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class MinimapTimeDisplay&#10;    {&#10;        private RectTransform minimapTimeContainer;&#10;        private Text minimapTimeText;&#10;        private MelonPreferences_Entry&lt;bool&gt; timeBarEnabled;&#10;&#10;        public RectTransform Container =&gt; minimapTimeContainer;&#10;        public Text TimeText =&gt; minimapTimeText;&#10;&#10;        private bool enabled { get { return timeBarEnabled.Value; } }&#10;&#10;        public void Create(Transform parent, MelonPreferences_Entry&lt;bool&gt; enabled)&#10;        {&#10;            timeBarEnabled = enabled;&#10;            GameObject containerObject = new GameObject(&quot;MinimapTimeContainer&quot;);&#10;            containerObject.transform.SetParent(parent, false);&#10;&#10;            minimapTimeContainer = containerObject.AddComponent&lt;RectTransform&gt;();&#10;            minimapTimeContainer.sizeDelta = new Vector2(Constants.TimeDisplayWidth, Constants.TimeDisplayHeight);&#10;            minimapTimeContainer.anchorMin = new Vector2(0.5f, 0f);&#10;            minimapTimeContainer.anchorMax = new Vector2(0.5f, 0f);&#10;            minimapTimeContainer.pivot = new Vector2(0.5f, 1f);&#10;&#10;            minimapTimeContainer.anchoredPosition = new Vector2(0f, Constants.TimeDisplayOffsetY);&#10;&#10;            Image backgroundImage = containerObject.AddComponent&lt;Image&gt;();&#10;            backgroundImage.color = new Color(&#10;                Constants.TimeBackgroundR, &#10;                Constants.TimeBackgroundG, &#10;                Constants.TimeBackgroundB, &#10;                Constants.TimeBackgroundA);&#10;&#10;            GameObject timeTextObject = new GameObject(&quot;MinimapTime&quot;);&#10;            timeTextObject.transform.SetParent(containerObject.transform, false);&#10;&#10;            RectTransform timeTextRect = timeTextObject.AddComponent&lt;RectTransform&gt;();&#10;            timeTextRect.anchorMin = new Vector2(0f, 0f);&#10;            timeTextRect.anchorMax = new Vector2(1f, 1f);&#10;            timeTextRect.anchoredPosition = Vector2.zero;&#10;&#10;            minimapTimeText = timeTextObject.AddComponent&lt;Text&gt;();&#10;            minimapTimeText.font = Resources.GetBuiltinResource&lt;Font&gt;(&quot;Arial.ttf&quot;);&#10;            minimapTimeText.fontSize = 16;&#10;            minimapTimeText.color = Color.white;&#10;            minimapTimeText.alignment = TextAnchor.MiddleCenter;&#10;            minimapTimeText.text = minimapTimeText.text ?? &quot;00:00:00&quot;;&#10;            minimapTimeText.raycastTarget = false;&#10;&#10;            if (!this.enabled)&#10;            {&#10;                containerObject.SetActive(false);&#10;            }&#10;        }&#10;&#10;        public void SetTimeBarEnabled(bool enabled)&#10;        {&#10;            timeBarEnabled.Value = enabled;&#10;            if (minimapTimeContainer != null)&#10;                minimapTimeContainer.gameObject.SetActive(enabled);&#10;        }&#10;&#10;        public void UpdateMinimapTime()&#10;        {&#10;            try&#10;            {&#10;                var currentTime = TimeManager.GetFormatted12HourTime();&#10;                var currentDay = TimeManager.CurrentDay;&#10;                if (minimapTimeText != null &amp;&amp; currentTime != null)&#10;                {&#10;                    minimapTimeText.text = currentDay.ToString() + &quot;\n&quot; + currentTime;&#10;                }&#10;            }&#10;            catch (System.Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;Error updating minimap time: &quot; + ex.Message);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/MinimapUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/MinimapUI.cs" />
              <option name="originalContent" value="#if IL2CPP&#10;using S1Quests = Il2CppScheduleOne.Quests;&#10;#else&#10;using S1Quests = ScheduleOne.Quests;&#10;#endif&#10;&#10;using S1API.Entities;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using System.Collections;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main;&#10;&#10;// The main orchestrator for the minimap UI and its managers.&#10;public class MinimapUI&#10;{&#10;    // --- Managers and Content ---&#10;    // Handles map content (image, grid, static markers)&#10;    private MinimapContent minimapContent;&#10;    // Handles player marker and direction indicator&#10;    private PlayerMarkerManager playerMarkerManager;&#10;    // Handles minimap time display&#10;    private MinimapTimeDisplay minimapTimeDisplay;&#10;&#10;    // --- UI GameObjects ---&#10;    private GameObject minimapObject;           // Root object for the minimap UI&#10;    private GameObject minimapDisplayObject;    // The mask object for the minimap&#10;    private RectTransform minimapFrameRect;     // The frame (positioned in the corner)&#10;&#10;    // --- State ---&#10;    private readonly MapPreferences mapPreferences;&#10;    private bool initialized = false;&#10;    &#10;    // --- Scaled sizes (calculated at runtime) ---&#10;    private float scaledMinimapSize;&#10;    private float scaledMapContentSize;&#10;    private Image minimapMaskImage; // Cache for regenerating mask sprite&#10;&#10;    // --- Cached Player Reference ---&#10;    private Player playerObject;&#10;&#10;    // Handles contract PoI markers&#10;    private ContractMarkerManager ContractMarkerManager { get; set; }&#10;&#10;    private bool TimeBarEnabled =&gt; mapPreferences.ShowGameTime.Value;&#10;    private bool MinimapEnabled =&gt; mapPreferences.MinimapEnabled.Value;&#10;&#10;    // Dynamic world-to-minimap scale reflecting user preference.&#10;    private float CurrentWorldScale =&gt; Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;&#10;    public MinimapUI(MapPreferences preferences)&#10;    {&#10;        mapPreferences = preferences;&#10;        mapPreferences.MinimapEnabled.OnEntryValueChanged.Subscribe(OnMinimapEnableChanged);&#10;        mapPreferences.ShowGameTime.OnEntryValueChanged.Subscribe(OnTimeBarEnableChanged);&#10;        mapPreferences.IncreaseSize.OnEntryValueChanged.Subscribe(OnIncreaseSizeChanged);&#10;        RecalculateScaledSizes();&#10;    }&#10;    &#10;    private void RecalculateScaledSizes()&#10;    {&#10;        var scale = mapPreferences.MinimapScaleFactor;&#10;        scaledMinimapSize = Constants.BaseMinimapSize * scale;&#10;        scaledMapContentSize = Constants.BaseMapContentSize * scale;&#10;    }&#10;    &#10;    private void OnIncreaseSizeChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (!initialized) return;&#10;        RecalculateScaledSizes();&#10;        UpdateMinimapSize(true); // regenerate mask sprite&#10;&#10;        // Update scale in ContractMarkerManager&#10;        var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;        ContractMarkerManager?.UpdateMapScale(currentScale);&#10;        &#10;        // Reproject all PoI markers using new scale&#10;        MinimapPoIHelper.UpdateAllMarkerPositions(CurrentWorldScale);&#10;        // Immediately recenter content so player marker remains centered after size jump&#10;        UpdateMinimap();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes the minimap UI and starts integration and update coroutines.&#10;    /// &lt;/summary&gt;&#10;    public void Initialize()&#10;    {&#10;        if (!MinimapEnabled) return;&#10;        CreateMinimapDisplay();&#10;        StartSceneIntegration();    // Finds map sprite, player, and sets up markers&#10;        StartMinimapUpdateLoop();   // Continuously updates minimap as player moves&#10;        initialized = true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cleans up the minimap UI when the scene changes or mod is unloaded.&#10;    /// &lt;/summary&gt;&#10;    public void Dispose()&#10;    {&#10;        if (minimapObject == null) return;&#10;        UnityEngine.Object.Destroy(minimapObject);&#10;        minimapObject = null;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates the minimap UI hierarchy, including mask, background, content, and managers.&#10;    /// &lt;/summary&gt;&#10;    private void CreateMinimapDisplay()&#10;    {&#10;        RecalculateScaledSizes();&#10;        &#10;        // Root container for minimap UI&#10;        minimapObject = new GameObject(&quot;MinimapContainer&quot;);&#10;        UnityEngine.Object.DontDestroyOnLoad(minimapObject);&#10;&#10;        // Canvas for UI rendering&#10;        var canvasObject = MinimapUIFactory.CreateCanvas(minimapObject);&#10;&#10;        // Frame (positions minimap in the corner)&#10;        var (frameObject, frameRect) = MinimapUIFactory.CreateFrame(canvasObject, scaledMinimapSize);&#10;        minimapFrameRect = frameRect;&#10;&#10;        // Mask (circular area for minimap)&#10;        var (maskObject, maskImage) = MinimapUIFactory.CreateMask(frameObject, scaledMinimapSize);&#10;        minimapDisplayObject = maskObject;&#10;        minimapMaskImage = maskImage;&#10;&#10;        // Map content (holds the map image, grid, and markers)&#10;        minimapContent = new MinimapContent(&#10;            scaledMapContentSize, &#10;            20, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor);&#10;        minimapContent.Create(maskObject);&#10;        TryApplyMapSprite(); // Try to assign the map image immediately&#10;&#10;        // Player marker (centered in the minimap)&#10;        playerMarkerManager = new PlayerMarkerManager();&#10;        playerMarkerManager.CreatePlayerMarker(maskObject);&#10;&#10;        // Contract PoI markers&#10;        ContractMarkerManager = new ContractMarkerManager(&#10;            minimapContent, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor, &#10;            Constants.ContractMarkerXOffset, &#10;            Constants.ContractMarkerZOffset,&#10;            mapPreferences);&#10;&#10;        // Time display (shows in-game time)&#10;        minimapTimeDisplay = new MinimapTimeDisplay();&#10;        minimapTimeDisplay.Create(minimapFrameRect, mapPreferences.ShowGameTime);&#10;    }&#10;&#10;    private void OnMinimapEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;&#10;        if (newValue &amp;&amp; !initialized)&#10;        {&#10;            Initialize();&#10;        }&#10;&#10;        if (oldValue == newValue) return;&#10;        if (minimapDisplayObject != null)&#10;            minimapDisplayObject.SetActive(MinimapEnabled);&#10;&#10;        if (MinimapEnabled)&#10;        {&#10;            UpdateMinimapSize();&#10;        }&#10;&#10;        minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;    }&#10;&#10;    private void OnTimeBarEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (oldValue != newValue)&#10;        {&#10;            minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap and its elements when the size changes (e.g., 2x toggle).&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimapSize(bool regenerateMaskSprite = false)&#10;    {&#10;        RecalculateScaledSizes();&#10;&#10;        if (minimapFrameRect != null)&#10;            minimapFrameRect.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;&#10;        if (minimapDisplayObject != null)&#10;        {&#10;            var component = minimapDisplayObject.GetComponent&lt;RectTransform&gt;();&#10;            component.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;            &#10;            if (regenerateMaskSprite &amp;&amp; minimapMaskImage != null)&#10;                minimapMaskImage.sprite = MinimapUIFactory.CreateCircleSprite((int)scaledMinimapSize, Color.black);&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null) return;&#10;        var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentRect != null)&#10;            contentRect.sizeDelta = new Vector2(scaledMapContentSize, scaledMapContentSize);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to find and assign the map sprite from the game's UI to the minimap.&#10;    /// &lt;/summary&gt;&#10;    private void TryApplyMapSprite()&#10;    {&#10;        &#10;        var contentGo = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        Image contentImage = null;&#10;        if (contentGo != null)&#10;        {&#10;            contentImage = contentGo.GetComponent&lt;Image&gt;();&#10;            if (contentImage == null &amp;&amp; contentGo.transform.childCount &gt; 0)&#10;                contentImage = contentGo.transform.GetChild(0).GetComponent&lt;Image&gt;();&#10;        }&#10;&#10;        if (contentImage != null &amp;&amp; minimapContent != null)&#10;        {&#10;            var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;            if (minimapImage == null)&#10;                minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;&#10;            minimapImage.sprite = contentImage.sprite;&#10;            minimapImage.type = Image.Type.Simple;&#10;            minimapImage.preserveAspect = true;&#10;            minimapImage.enabled = true;&#10;            MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap.&quot;);&#10;        }&#10;        else&#10;        {&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find map sprite to apply to minimap.&quot;);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that integrates the minimap with the scene (finds player, map, markers).&#10;    /// &lt;/summary&gt;&#10;    private void StartSceneIntegration()&#10;    {&#10;        MelonCoroutines.Start(SceneIntegrationRoutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that finds the player, map sprite, and sets up markers after the scene loads.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator SceneIntegrationRoutine()&#10;    {&#10;        MelonLogger.Msg(&quot;MinimapUI: Looking for game objects...&quot;);&#10;&#10;        yield return new WaitForSeconds(2f);&#10;&#10;        GameObject mapAppObject = null;&#10;        GameObject viewportObject = null;&#10;&#10;        var attempts = 0;&#10;        while ((mapAppObject == null || playerObject == null) &amp;&amp; attempts &lt; 30)&#10;        {&#10;            attempts++;&#10;&#10;            // Find player by looking for a CharacterController not at world origin&#10;            playerObject ??= Player.Local;&#10;&#10;            // Find the MapApp UI object&#10;            if (mapAppObject == null)&#10;            {&#10;                var gameplayMenu = GameObject.Find(&quot;GameplayMenu&quot;);&#10;                if (gameplayMenu != null)&#10;                {&#10;                    var phoneTransform = gameplayMenu.transform.Find(&quot;Phone&quot;);&#10;                    if (phoneTransform != null)&#10;                    {&#10;                        var phoneChildTransform = phoneTransform.Find(&quot;phone&quot;);&#10;                        if (phoneChildTransform != null)&#10;                        {&#10;                            var appsCanvas = phoneChildTransform.Find(&quot;AppsCanvas&quot;);&#10;                            if (appsCanvas != null)&#10;                            {&#10;                                var mapApp = appsCanvas.Find(&quot;MapApp&quot;);&#10;                                if (mapApp != null)&#10;                                {&#10;                                    mapAppObject = mapApp.gameObject;&#10;                                    MelonLogger.Msg(&quot;MinimapUI: Found MapApp&quot;);&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Find the viewport (where the map image is)&#10;            if (mapAppObject != null &amp;&amp; viewportObject == null)&#10;            {&#10;                var container = mapAppObject.transform.Find(&quot;Container&quot;);&#10;                if (container != null)&#10;                {&#10;                    var scrollView = container.Find(&quot;Scroll View&quot;);&#10;                    if (scrollView != null)&#10;                    {&#10;                        var viewport = scrollView.Find(&quot;Viewport&quot;);&#10;                        if (viewport != null)&#10;                        {&#10;                            viewportObject = viewport.gameObject;&#10;                            MelonLogger.Msg(&quot;MinimapUI: Found Map Viewport&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (mapAppObject == null || playerObject == null)&#10;                yield return new WaitForSeconds(Constants.SceneIntegrationRetryDelay);&#10;        }&#10;&#10;        if (mapAppObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Map App after multiple attempts&quot;);&#10;        else if (viewportObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Found MapApp but could not find Viewport&quot;);&#10;        if (playerObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Player after multiple attempts&quot;);&#10;&#10;        MelonLogger.Msg(&quot;MinimapUI: Game object search completed&quot;);&#10;&#10;        // Apply map sprite from the viewport's content image&#10;        if (viewportObject != null)&#10;        {&#10;            try&#10;            {&#10;                if (viewportObject.transform.childCount &gt; 0)&#10;                {&#10;                    var contentTransform = viewportObject.transform.GetChild(0);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Found viewport content: &quot; + contentTransform.name);&#10;                    var contentImage = contentTransform.GetComponent&lt;Image&gt;();&#10;&#10;                    if (contentImage != null &amp;&amp; contentImage.sprite != null)&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Found content image with sprite: &quot; + contentImage.sprite.name);&#10;&#10;                        var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                        if (minimapImage == null)&#10;                            minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                        minimapImage.sprite = contentImage.sprite;&#10;                        minimapImage.type = Image.Type.Simple;&#10;                        minimapImage.preserveAspect = true;&#10;                        minimapImage.enabled = true;&#10;                        MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                        if (minimapContent.GridContainer != null)&#10;                            minimapContent.GridContainer.gameObject.SetActive(false);&#10;                    }&#10;                    else&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Content doesn't have an Image component or sprite&quot;);&#10;                        // Try children for a valid image&#10;                        var childCount = contentTransform.childCount;&#10;                        for (var i = 0; i &lt; childCount; i++)&#10;                        {&#10;                            var child = contentTransform.GetChild(i);&#10;                            var childImage = child.GetComponent&lt;Image&gt;();&#10;                            if (childImage != null &amp;&amp; childImage.sprite != null)&#10;                            {&#10;                                MelonLogger.Msg(&quot;MinimapUI: Found image in content child: &quot; + child.name + &quot;, Sprite: &quot; + childImage.sprite.name);&#10;&#10;                                var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                                if (minimapImage == null)&#10;                                    minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                                minimapImage.sprite = childImage.sprite;&#10;                                minimapImage.type = Image.Type.Simple;&#10;                                minimapImage.preserveAspect = true;&#10;                                minimapImage.enabled = true;&#10;                                MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                                if (minimapContent.GridContainer != null)&#10;                                    minimapContent.GridContainer.gameObject.SetActive(false);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;MinimapUI: Error accessing map content: &quot; + ex.Message);&#10;            }&#10;        }&#10;&#10;        // Replace fallback player marker with real icon if available&#10;        var cachedMapContent = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        if (cachedMapContent != null)&#10;        {&#10;            var playerPoI = cachedMapContent.transform.Find(&quot;PlayerPoI(Clone)&quot;);&#10;            if (playerPoI != null)&#10;            {&#10;                var realIcon = playerPoI.Find(&quot;IconContainer&quot;);&#10;                if (realIcon != null)&#10;                {&#10;                    playerMarkerManager.ReplaceWithRealPlayerIcon(realIcon.gameObject);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Replaced fallback player marker with real player icon.&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add default static markers if possible&#10;        if (cachedMapContent != null)&#10;        {&#10;            var propertyPoI = cachedMapContent.transform.Find(&quot;PropertyPoI(Clone)&quot;);&#10;            if (propertyPoI == null) yield break;&#10;            &#10;            var iconContainer = propertyPoI.Find(&quot;IconContainer&quot;);&#10;            if (iconContainer == null) yield break;&#10;            &#10;            PropertyPoIManager.Initialize(minimapContent, iconContainer);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that updates the minimap every frame.&#10;    /// &lt;/summary&gt;&#10;    private void StartMinimapUpdateLoop()&#10;    {&#10;        MelonCoroutines.Start(MinimapUpdateLoopCoroutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that updates the minimap's content position and player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator MinimapUpdateLoopCoroutine()&#10;    {&#10;        while (true)&#10;        {&#10;            UpdateMinimap();&#10;            yield return null;&#10;        }&#10;        // ReSharper disable once IteratorNeverReturns&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap's content position to keep the player centered, and updates the player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimap()&#10;    {&#10;        if (playerObject == null)&#10;        {&#10;            playerObject = Player.Local;&#10;&#10;            if (playerObject == null)&#10;                return;&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null)&#10;            return;&#10;        &#10;        // Use dynamic world scale that reflects current minimap size preference&#10;        var worldScale = CurrentWorldScale;&#10;        var position = playerObject.Position;&#10;        var mappedX = -position.x * worldScale;&#10;        var mappedZ = -position.z * worldScale;&#10;        var minimapMask = minimapDisplayObject.transform.Find(&quot;MinimapMask&quot;);&#10;        var zero = Vector2.zero;&#10;&#10;        if (minimapMask != null)&#10;        {&#10;            var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;            if (contentRect != null)&#10;            {&#10;                var rect = contentRect.rect;&#10;                var halfWidth = rect.width * 0.5f;&#10;                contentRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                zero = new Vector2(halfWidth, rect.height * 0.5f);&#10;            }&#10;        }&#10;&#10;        // Position of the player marker on the minimap (offset scaled with map)&#10;        var scaleFactor = mapPreferences.MinimapScaleFactor;&#10;        var sizeVector = new Vector2(&#10;            Constants.PlayerMarkerOffsetX * scaleFactor, &#10;            Constants.PlayerMarkerOffsetZ * scaleFactor);&#10;        var heightVector = new Vector2(mappedX, mappedZ) + zero + sizeVector;&#10;&#10;        var contentObject = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentObject != null)&#10;        {&#10;            contentObject.anchoredPosition = Vector2.Lerp(&#10;                contentObject.anchoredPosition,&#10;                heightVector,&#10;                Time.deltaTime * Constants.MapContentLerpSpeed);&#10;&#10;            // Update player marker direction indicator&#10;            playerMarkerManager?.UpdateDirectionIndicator(playerObject.Transform);&#10;        }&#10;        &#10;        minimapTimeDisplay.UpdateMinimapTime();&#10;    }&#10;&#10;&#10;    internal void OnContractAccepted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.AddContractPoIMarkerWorld(contract);&#10;    }&#10;&#10;    internal void OnContractCompleted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.RemoveContractPoIMarkers(contract);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#if IL2CPP&#10;using S1Quests = Il2CppScheduleOne.Quests;&#10;#else&#10;using S1Quests = ScheduleOne.Quests;&#10;#endif&#10;&#10;using S1API.Entities;&#10;using MelonLoader;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;using System.Collections;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main;&#10;&#10;// The main orchestrator for the minimap UI and its managers.&#10;public class MinimapUI&#10;{&#10;    // --- Managers and Content ---&#10;    // Handles map content (image, grid, static markers)&#10;    private MinimapContent minimapContent;&#10;    // Handles player marker and direction indicator&#10;    private PlayerMarkerManager playerMarkerManager;&#10;    // Handles minimap time display&#10;    private MinimapTimeDisplay minimapTimeDisplay;&#10;&#10;    // --- UI GameObjects ---&#10;    private GameObject minimapObject;           // Root object for the minimap UI&#10;    private GameObject minimapDisplayObject;    // The mask object for the minimap&#10;    private RectTransform minimapFrameRect;     // The frame (positioned in the corner)&#10;&#10;    // --- State ---&#10;    private readonly MapPreferences mapPreferences;&#10;    private bool initialized = false;&#10;    &#10;    // --- Scaled sizes (calculated at runtime) ---&#10;    private float scaledMinimapSize;&#10;    private float scaledMapContentSize;&#10;    private Image minimapMaskImage; // Cache for regenerating mask sprite&#10;&#10;    // --- Cached Player Reference ---&#10;    private Player playerObject;&#10;&#10;    // Handles contract PoI markers&#10;    private ContractMarkerManager ContractMarkerManager { get; set; }&#10;&#10;    private bool TimeBarEnabled =&gt; mapPreferences.ShowGameTime.Value;&#10;    private bool MinimapEnabled =&gt; mapPreferences.MinimapEnabled.Value;&#10;&#10;    // Dynamic world-to-minimap scale reflecting user preference.&#10;    private float CurrentWorldScale =&gt; Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;&#10;    public MinimapUI(MapPreferences preferences)&#10;    {&#10;        mapPreferences = preferences;&#10;        mapPreferences.MinimapEnabled.OnEntryValueChanged.Subscribe(OnMinimapEnableChanged);&#10;        mapPreferences.ShowGameTime.OnEntryValueChanged.Subscribe(OnTimeBarEnableChanged);&#10;        mapPreferences.IncreaseSize.OnEntryValueChanged.Subscribe(OnIncreaseSizeChanged);&#10;        RecalculateScaledSizes();&#10;    }&#10;    &#10;    private void RecalculateScaledSizes()&#10;    {&#10;        var scale = mapPreferences.MinimapScaleFactor;&#10;        scaledMinimapSize = Constants.BaseMinimapSize * scale;&#10;        scaledMapContentSize = Constants.BaseMapContentSize * scale;&#10;    }&#10;    &#10;    private void OnIncreaseSizeChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (!initialized) return;&#10;        RecalculateScaledSizes();&#10;        UpdateMinimapSize(true); // regenerate mask sprite&#10;&#10;        // Update scale in ContractMarkerManager&#10;        var currentScale = Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor;&#10;        ContractMarkerManager?.UpdateMapScale(currentScale);&#10;        &#10;        // Reproject all PoI markers using new scale&#10;        MinimapPoIHelper.UpdateAllMarkerPositions(CurrentWorldScale);&#10;        // Immediately recenter content so player marker remains centered after size jump&#10;        UpdateMinimap();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes the minimap UI and starts integration and update coroutines.&#10;    /// &lt;/summary&gt;&#10;    public void Initialize()&#10;    {&#10;        if (!MinimapEnabled) return;&#10;        CreateMinimapDisplay();&#10;        StartSceneIntegration();    // Finds map sprite, player, and sets up markers&#10;        StartMinimapUpdateLoop();   // Continuously updates minimap as player moves&#10;        initialized = true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cleans up the minimap UI when the scene changes or mod is unloaded.&#10;    /// &lt;/summary&gt;&#10;    public void Dispose()&#10;    {&#10;        if (minimapObject == null) return;&#10;        UnityEngine.Object.Destroy(minimapObject);&#10;        minimapObject = null;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates the minimap UI hierarchy, including mask, background, content, and managers.&#10;    /// &lt;/summary&gt;&#10;    private void CreateMinimapDisplay()&#10;    {&#10;        RecalculateScaledSizes();&#10;        &#10;        // Root container for minimap UI&#10;        minimapObject = new GameObject(&quot;MinimapContainer&quot;);&#10;        UnityEngine.Object.DontDestroyOnLoad(minimapObject);&#10;&#10;        // Canvas for UI rendering&#10;        var canvasObject = MinimapUIFactory.CreateCanvas(minimapObject);&#10;&#10;        // Frame (positions minimap in the corner)&#10;        var (frameObject, frameRect) = MinimapUIFactory.CreateFrame(canvasObject, scaledMinimapSize);&#10;        minimapFrameRect = frameRect;&#10;&#10;        // Mask (circular area for minimap)&#10;        var (maskObject, maskImage) = MinimapUIFactory.CreateMask(frameObject, scaledMinimapSize);&#10;        minimapDisplayObject = maskObject;&#10;        minimapMaskImage = maskImage;&#10;&#10;        // Map content (holds the map image, grid, and markers)&#10;        minimapContent = new MinimapContent(&#10;            scaledMapContentSize, &#10;            20, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor);&#10;        minimapContent.Create(maskObject);&#10;        TryApplyMapSprite(); // Try to assign the map image immediately&#10;&#10;        // Player marker (centered in the minimap)&#10;        playerMarkerManager = new PlayerMarkerManager();&#10;        playerMarkerManager.CreatePlayerMarker(maskObject);&#10;&#10;        // Contract PoI markers&#10;        ContractMarkerManager = new ContractMarkerManager(&#10;            minimapContent, &#10;            Constants.DefaultMapScale * mapPreferences.MinimapScaleFactor, &#10;            Constants.ContractMarkerXOffset, &#10;            Constants.ContractMarkerZOffset,&#10;            mapPreferences);&#10;&#10;        // Time display (shows in-game time)&#10;        minimapTimeDisplay = new MinimapTimeDisplay();&#10;        minimapTimeDisplay.Create(minimapFrameRect, mapPreferences.ShowGameTime);&#10;    }&#10;&#10;    private void OnMinimapEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;&#10;        if (newValue &amp;&amp; !initialized)&#10;        {&#10;            Initialize();&#10;        }&#10;&#10;        if (oldValue == newValue) return;&#10;        if (minimapDisplayObject != null)&#10;            minimapDisplayObject.SetActive(MinimapEnabled);&#10;&#10;        if (MinimapEnabled)&#10;        {&#10;            UpdateMinimapSize();&#10;        }&#10;&#10;        minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;    }&#10;&#10;    private void OnTimeBarEnableChanged(bool oldValue, bool newValue)&#10;    {&#10;        if (oldValue != newValue)&#10;        {&#10;            minimapTimeDisplay?.SetTimeBarEnabled(TimeBarEnabled);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap and its elements when the size changes (e.g., 2x toggle).&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimapSize(bool regenerateMaskSprite = false)&#10;    {&#10;        RecalculateScaledSizes();&#10;&#10;        if (minimapFrameRect != null)&#10;            minimapFrameRect.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;&#10;        if (minimapDisplayObject != null)&#10;        {&#10;            var component = minimapDisplayObject.GetComponent&lt;RectTransform&gt;();&#10;            component.sizeDelta = new Vector2(scaledMinimapSize, scaledMinimapSize);&#10;            &#10;            if (regenerateMaskSprite &amp;&amp; minimapMaskImage != null)&#10;                minimapMaskImage.sprite = MinimapUIFactory.CreateCircleSprite((int)scaledMinimapSize, Color.black);&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null) return;&#10;        var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentRect != null)&#10;            contentRect.sizeDelta = new Vector2(scaledMapContentSize, scaledMapContentSize);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to find and assign the map sprite from the game's UI to the minimap.&#10;    /// &lt;/summary&gt;&#10;    private void TryApplyMapSprite()&#10;    {&#10;        &#10;        var contentGo = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        Image contentImage = null;&#10;        if (contentGo != null)&#10;        {&#10;            contentImage = contentGo.GetComponent&lt;Image&gt;();&#10;            if (contentImage == null &amp;&amp; contentGo.transform.childCount &gt; 0)&#10;                contentImage = contentGo.transform.GetChild(0).GetComponent&lt;Image&gt;();&#10;        }&#10;&#10;        if (contentImage != null &amp;&amp; minimapContent != null)&#10;        {&#10;            var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;            if (minimapImage == null)&#10;                minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;&#10;            minimapImage.sprite = contentImage.sprite;&#10;            minimapImage.type = Image.Type.Simple;&#10;            minimapImage.preserveAspect = true;&#10;            minimapImage.enabled = true;&#10;            MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap.&quot;);&#10;        }&#10;        else&#10;        {&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find map sprite to apply to minimap.&quot;);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that integrates the minimap with the scene (finds player, map, markers).&#10;    /// &lt;/summary&gt;&#10;    private void StartSceneIntegration()&#10;    {&#10;        MelonCoroutines.Start(SceneIntegrationRoutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that finds the player, map sprite, and sets up markers after the scene loads.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator SceneIntegrationRoutine()&#10;    {&#10;        MelonLogger.Msg(&quot;MinimapUI: Looking for game objects...&quot;);&#10;&#10;        yield return new WaitForSeconds(2f);&#10;&#10;        GameObject mapAppObject = null;&#10;        GameObject viewportObject = null;&#10;&#10;        var attempts = 0;&#10;        while ((mapAppObject == null || playerObject == null) &amp;&amp; attempts &lt; 30)&#10;        {&#10;            attempts++;&#10;&#10;            // Find player by looking for a CharacterController not at world origin&#10;            playerObject ??= Player.Local;&#10;&#10;            // Find the MapApp UI object&#10;            if (mapAppObject == null)&#10;            {&#10;                var gameplayMenu = GameObject.Find(&quot;GameplayMenu&quot;);&#10;                if (gameplayMenu != null)&#10;                {&#10;                    var phoneTransform = gameplayMenu.transform.Find(&quot;Phone&quot;);&#10;                    if (phoneTransform != null)&#10;                    {&#10;                        var phoneChildTransform = phoneTransform.Find(&quot;phone&quot;);&#10;                        if (phoneChildTransform != null)&#10;                        {&#10;                            var appsCanvas = phoneChildTransform.Find(&quot;AppsCanvas&quot;);&#10;                            if (appsCanvas != null)&#10;                            {&#10;                                var mapApp = appsCanvas.Find(&quot;MapApp&quot;);&#10;                                if (mapApp != null)&#10;                                {&#10;                                    mapAppObject = mapApp.gameObject;&#10;                                    MelonLogger.Msg(&quot;MinimapUI: Found MapApp&quot;);&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Find the viewport (where the map image is)&#10;            if (mapAppObject != null &amp;&amp; viewportObject == null)&#10;            {&#10;                var container = mapAppObject.transform.Find(&quot;Container&quot;);&#10;                if (container != null)&#10;                {&#10;                    var scrollView = container.Find(&quot;Scroll View&quot;);&#10;                    if (scrollView != null)&#10;                    {&#10;                        var viewport = scrollView.Find(&quot;Viewport&quot;);&#10;                        if (viewport != null)&#10;                        {&#10;                            viewportObject = viewport.gameObject;&#10;                            MelonLogger.Msg(&quot;MinimapUI: Found Map Viewport&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (mapAppObject == null || playerObject == null)&#10;                yield return new WaitForSeconds(Constants.SceneIntegrationRetryDelay);&#10;        }&#10;&#10;        if (mapAppObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Map App after multiple attempts&quot;);&#10;        else if (viewportObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Found MapApp but could not find Viewport&quot;);&#10;        if (playerObject == null)&#10;            MelonLogger.Warning(&quot;MinimapUI: Could not find Player after multiple attempts&quot;);&#10;&#10;        MelonLogger.Msg(&quot;MinimapUI: Game object search completed&quot;);&#10;&#10;        // Apply map sprite from the viewport's content image&#10;        if (viewportObject != null)&#10;        {&#10;            try&#10;            {&#10;                if (viewportObject.transform.childCount &gt; 0)&#10;                {&#10;                    var contentTransform = viewportObject.transform.GetChild(0);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Found viewport content: &quot; + contentTransform.name);&#10;                    var contentImage = contentTransform.GetComponent&lt;Image&gt;();&#10;&#10;                    if (contentImage != null &amp;&amp; contentImage.sprite != null)&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Found content image with sprite: &quot; + contentImage.sprite.name);&#10;&#10;                        var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                        if (minimapImage == null)&#10;                            minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                        minimapImage.sprite = contentImage.sprite;&#10;                        minimapImage.type = Image.Type.Simple;&#10;                        minimapImage.preserveAspect = true;&#10;                        minimapImage.enabled = true;&#10;                        MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                        if (minimapContent.GridContainer != null)&#10;                            minimapContent.GridContainer.gameObject.SetActive(false);&#10;                    }&#10;                    else&#10;                    {&#10;                        MelonLogger.Msg(&quot;MinimapUI: Content doesn't have an Image component or sprite&quot;);&#10;                        // Try children for a valid image&#10;                        var childCount = contentTransform.childCount;&#10;                        for (var i = 0; i &lt; childCount; i++)&#10;                        {&#10;                            var child = contentTransform.GetChild(i);&#10;                            var childImage = child.GetComponent&lt;Image&gt;();&#10;                            if (childImage != null &amp;&amp; childImage.sprite != null)&#10;                            {&#10;                                MelonLogger.Msg(&quot;MinimapUI: Found image in content child: &quot; + child.name + &quot;, Sprite: &quot; + childImage.sprite.name);&#10;&#10;                                var minimapImage = minimapContent.MapContentObject.GetComponent&lt;Image&gt;();&#10;                                if (minimapImage == null)&#10;                                    minimapImage = minimapContent.MapContentObject.AddComponent&lt;Image&gt;();&#10;                                minimapImage.sprite = childImage.sprite;&#10;                                minimapImage.type = Image.Type.Simple;&#10;                                minimapImage.preserveAspect = true;&#10;                                minimapImage.enabled = true;&#10;                                MelonLogger.Msg(&quot;MinimapUI: Successfully applied map sprite to minimap!&quot;);&#10;&#10;                                if (minimapContent.GridContainer != null)&#10;                                    minimapContent.GridContainer.gameObject.SetActive(false);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                MelonLogger.Error(&quot;MinimapUI: Error accessing map content: &quot; + ex.Message);&#10;            }&#10;        }&#10;&#10;        // Replace fallback player marker with real icon if available&#10;        var cachedMapContent = GameObject.Find(&quot;GameplayMenu/Phone/phone/AppsCanvas/MapApp/Container/Scroll View/Viewport/Content&quot;);&#10;        if (cachedMapContent != null)&#10;        {&#10;            var playerPoI = cachedMapContent.transform.Find(&quot;PlayerPoI(Clone)&quot;);&#10;            if (playerPoI != null)&#10;            {&#10;                var realIcon = playerPoI.Find(&quot;IconContainer&quot;);&#10;                if (realIcon != null)&#10;                {&#10;                    playerMarkerManager.ReplaceWithRealPlayerIcon(realIcon.gameObject);&#10;                    MelonLogger.Msg(&quot;MinimapUI: Replaced fallback player marker with real player icon.&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Add default static markers if possible&#10;        if (cachedMapContent != null)&#10;        {&#10;            var propertyPoI = cachedMapContent.transform.Find(&quot;PropertyPoI(Clone)&quot;);&#10;            if (propertyPoI == null) yield break;&#10;            &#10;            var iconContainer = propertyPoI.Find(&quot;IconContainer&quot;);&#10;            if (iconContainer == null) yield break;&#10;            &#10;            PropertyPoIManager.Initialize(minimapContent, iconContainer);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Starts the coroutine that updates the minimap every frame.&#10;    /// &lt;/summary&gt;&#10;    private void StartMinimapUpdateLoop()&#10;    {&#10;        MelonCoroutines.Start(MinimapUpdateLoopCoroutine());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Coroutine that updates the minimap's content position and player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private IEnumerator MinimapUpdateLoopCoroutine()&#10;    {&#10;        while (true)&#10;        {&#10;            UpdateMinimap();&#10;            yield return null;&#10;        }&#10;        // ReSharper disable once IteratorNeverReturns&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimap's content position to keep the player centered, and updates the player marker direction.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMinimap()&#10;    {&#10;        if (playerObject == null)&#10;        {&#10;            playerObject = Player.Local;&#10;&#10;            if (playerObject == null)&#10;                return;&#10;        }&#10;&#10;        if (minimapContent?.MapContentObject == null)&#10;            return;&#10;        &#10;        // Use dynamic world scale that reflects current minimap size preference&#10;        var worldScale = CurrentWorldScale;&#10;        var position = playerObject.Position;&#10;        var mappedX = -position.x * worldScale;&#10;        var mappedZ = -position.z * worldScale;&#10;        var minimapMask = minimapDisplayObject.transform.Find(&quot;MinimapMask&quot;);&#10;        var zero = Vector2.zero;&#10;&#10;        if (minimapMask != null)&#10;        {&#10;            var contentRect = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;            if (contentRect != null)&#10;            {&#10;                var rect = contentRect.rect;&#10;                var halfWidth = rect.width * 0.5f;&#10;                contentRect.anchoredPosition = new Vector2(mappedX, mappedZ);&#10;                zero = new Vector2(halfWidth, rect.height * 0.5f);&#10;            }&#10;        }&#10;&#10;        // Position of the player marker on the minimap (offset scaled with map)&#10;        var scaleFactor = mapPreferences.MinimapScaleFactor;&#10;        var sizeVector = new Vector2(&#10;            Constants.PlayerMarkerOffsetX * scaleFactor, &#10;            Constants.PlayerMarkerOffsetZ * scaleFactor);&#10;        var heightVector = new Vector2(mappedX, mappedZ) + zero + sizeVector;&#10;&#10;        var contentObject = minimapContent.MapContentObject.GetComponent&lt;RectTransform&gt;();&#10;        if (contentObject != null)&#10;        {&#10;            contentObject.anchoredPosition = Vector2.Lerp(&#10;                contentObject.anchoredPosition,&#10;                heightVector,&#10;                Time.deltaTime * Constants.MapContentLerpSpeed);&#10;&#10;            // Update player marker direction indicator&#10;            playerMarkerManager?.UpdateDirectionIndicator(playerObject.Transform);&#10;        }&#10;        &#10;        minimapTimeDisplay.UpdateMinimapTime();&#10;    }&#10;&#10;&#10;    internal void OnContractAccepted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.AddContractPoIMarkerWorld(contract);&#10;    }&#10;&#10;    internal void OnContractCompleted(S1Quests.Contract contract)&#10;    {&#10;        ContractMarkerManager.RemoveContractPoIMarkers(contract);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main/PlayerMarkerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main/PlayerMarkerManager.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class PlayerMarkerManager&#10;    {&#10;        private RectTransform directionIndicator;&#10;        private readonly Color markerColor = new Color(0.2f, 0.6f, 1f, 1f);&#10;&#10;        private GameObject Marker { get; set; }&#10;&#10;        public void CreatePlayerMarker(GameObject parent)&#10;        {&#10;            Marker = MinimapUIFactory.CreatePlayerMarker(parent, markerColor);&#10;        }&#10;&#10;        public void ReplaceWithRealPlayerIcon(GameObject realIconPrefab)&#10;        {&#10;            if (Marker == null || realIconPrefab == null)&#10;                return;&#10;&#10;            var newMarker = UnityEngine.Object.Instantiate(realIconPrefab, Marker.transform.parent, false);&#10;            newMarker.name = &quot;PlayerMarker&quot;;&#10;            var newRect = newMarker.GetComponent&lt;RectTransform&gt;();&#10;            if (newRect != null)&#10;            {&#10;                newRect.anchoredPosition = Vector2.zero;&#10;                newRect.localScale = new Vector3(&#10;                    Constants.PlayerIconReplacementScale, &#10;                    Constants.PlayerIconReplacementScale, &#10;                    Constants.PlayerIconReplacementScale);&#10;            }&#10;&#10;            // Remove arrow if present&#10;            var arrowImage = newMarker.transform.Find(&quot;Image&quot;);&#10;            if (arrowImage != null)&#10;            {&#10;                UnityEngine.Object.Destroy(arrowImage.gameObject);&#10;            }&#10;&#10;            UnityEngine.Object.Destroy(Marker);&#10;            Marker = newMarker;&#10;            Marker.transform.SetAsLastSibling();&#10;        }&#10;&#10;        public void UpdateDirectionIndicator(Transform playerTransform)&#10;        {&#10;            if (Marker == null || playerTransform == null)&#10;                return;&#10;&#10;            if (directionIndicator == null)&#10;            {&#10;                var indicatorTransform = Marker.transform.Find(&quot;DirectionIndicator&quot;);&#10;                if (indicatorTransform != null)&#10;                {&#10;                    directionIndicator = (RectTransform)indicatorTransform;&#10;                }&#10;                else&#10;                {&#10;                    directionIndicator = MinimapUIFactory.CreateDirectionIndicator(Marker, Color.white);&#10;                }&#10;            }&#10;&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            var indicatorDistance = Constants.DirectionIndicatorDistance;&#10;            var rotation = playerTransform.rotation;&#10;            var yRotation = rotation.eulerAngles.y;&#10;            var angleRad = (90f - yRotation) * Mathf.Deg2Rad;&#10;&#10;            var newPosition = new Vector2(&#10;                indicatorDistance * Mathf.Cos(angleRad),&#10;                indicatorDistance * Mathf.Sin(angleRad)&#10;            );&#10;            directionIndicator.anchoredPosition = newPosition;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using Small_Corner_Map.Helpers;&#10;&#10;namespace Small_Corner_Map.Main&#10;{&#10;    public class PlayerMarkerManager&#10;    {&#10;        private RectTransform directionIndicator;&#10;        private readonly Color markerColor = new Color(0.2f, 0.6f, 1f, 1f);&#10;&#10;        private GameObject Marker { get; set; }&#10;&#10;        public void CreatePlayerMarker(GameObject parent)&#10;        {&#10;            Marker = MinimapUIFactory.CreatePlayerMarker(parent, markerColor);&#10;        }&#10;&#10;        public void ReplaceWithRealPlayerIcon(GameObject realIconPrefab)&#10;        {&#10;            if (Marker == null || realIconPrefab == null)&#10;                return;&#10;&#10;            var newMarker = UnityEngine.Object.Instantiate(realIconPrefab, Marker.transform.parent, false);&#10;            newMarker.name = &quot;PlayerMarker&quot;;&#10;            var newRect = newMarker.GetComponent&lt;RectTransform&gt;();&#10;            if (newRect != null)&#10;            {&#10;                newRect.anchoredPosition = Vector2.zero;&#10;                newRect.localScale = new Vector3(&#10;                    Constants.PlayerIconReplacementScale, &#10;                    Constants.PlayerIconReplacementScale, &#10;                    Constants.PlayerIconReplacementScale);&#10;            }&#10;&#10;            // Remove arrow if present&#10;            var arrowImage = newMarker.transform.Find(&quot;Image&quot;);&#10;            if (arrowImage != null)&#10;            {&#10;                UnityEngine.Object.Destroy(arrowImage.gameObject);&#10;            }&#10;&#10;            UnityEngine.Object.Destroy(Marker);&#10;            Marker = newMarker;&#10;            Marker.transform.SetAsLastSibling();&#10;        }&#10;&#10;        public void UpdateDirectionIndicator(Transform playerTransform)&#10;        {&#10;            if (Marker == null || playerTransform == null)&#10;                return;&#10;&#10;            if (directionIndicator == null)&#10;            {&#10;                var indicatorTransform = Marker.transform.Find(&quot;DirectionIndicator&quot;);&#10;                if (indicatorTransform != null)&#10;                {&#10;                    directionIndicator = (RectTransform)indicatorTransform;&#10;                }&#10;                else&#10;                {&#10;                    directionIndicator = MinimapUIFactory.CreateDirectionIndicator(Marker, Color.white);&#10;                }&#10;            }&#10;&#10;            directionIndicator.pivot = new Vector2(0.5f, 0.5f);&#10;            var indicatorDistance = Constants.DirectionIndicatorDistance;&#10;            var rotation = playerTransform.rotation;&#10;            var yRotation = rotation.eulerAngles.y;&#10;            var angleRad = (90f - yRotation) * Mathf.Deg2Rad;&#10;&#10;            var newPosition = new Vector2(&#10;                indicatorDistance * Mathf.Cos(angleRad),&#10;                indicatorDistance * Mathf.Sin(angleRad)&#10;            );&#10;            directionIndicator.anchoredPosition = newPosition;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>